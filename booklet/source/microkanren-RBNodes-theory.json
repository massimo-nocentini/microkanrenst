{	"classes" : {		"RBNodePredicatesTest" : {			"hash" : 3380992,			"definition" : "Srfi41AbstractTest subclass: #RBNodePredicatesTest\r\tuses: TIceImagesExporting\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-Tests'",			"comment" : [				"This class contains tests"			],			"category" : "MicroKanren-Tests"		},		"OCASTTranslator" : {			"hash" : 1248768,			"definition" : "RBProgramNodeVisitor subclass: #OCASTTranslator\r\tinstanceVariableNames: 'methodBuilder effectTranslator valueTranslator'\r\tclassVariableNames: 'OptimizedMessages'\r\tpackage: 'OpalCompiler-Core-Translator'",			"comment" : [				"I visit an abstract syntax tree and generate IR (intermediate representation) instructions for each node by sending the appropriate message to my methodBuilder (an IRBuilder).  I hold onto my two subclasses ",				"OCASTTranslatorForValue for generating instructions for effect and value, and",				"OCASTTranslatorForEffect for generating instructions for effect only.",				"",				"Which one to use depends on the AST nodes and whether the code will only be executed (for effect only) or if the value is used afterwards (for value).",				"",				"For example, when translating a return, the value to return needs to be pushed on stack, so the valueTranslator is used:",				"visitReturnNode: aReturnNode ",				"\tvalueTranslator visitNode: aReturnNode value.",				"\tmethodBuilder returnTop.",				"\t",				"Whereas, in #visitMethodNode:,  the effectTranslator is used, because no value is pushed on stack at the end of the method body:",				"...effectTranslator visitNode: aMethodNode body.."			],			"category" : "OpalCompiler-Core-Translator"		},		"FBDOptimizedMessagesRewriter" : {			"hash" : 1668352,			"definition" : "RBProgramNodeVisitor subclass: #FBDOptimizedMessagesRewriter\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Flashback-Decompiler-Utilities'",			"comment" : [				"I am a tool that allows you to reoptimize messages into a decompiled method.",				"",				"I receive an AST and I replace non-optimized message nodes that have been reconstructed by the AST builder into optimized message nodes, then I return the AST.",				"",				"Public API : use rewriteAST: to transform it with optimized messages.",				"",				"example: FBDOptimizedMessagesRewriter rewriteAST: (Object >> #asString ) ast.",				"",				"I only rewrite nodes with \"reconstructed\" property to ensure that I reoptimize only the messages that were optimized in the non-decompiled method."			],			"category" : "Flashback-Decompiler-Utilities"		},		"CDClassDefinitionParser" : {			"hash" : 4324608,			"definition" : "CDAbstractClassDefinitionParser subclass: #CDClassDefinitionParser\r\tinstanceVariableNames: 'subclass'\r\tclassVariableNames: ''\r\tpackage: 'ClassParser-Parser'",			"comment" : [				"I use the default node representation of classes to parse class definition and  return a dedicated class tree.",				"",				"The basic idea behing the implementation is to reuse as much as possible as the current parser infrastructure. This is why this class defines a visitMessageNode: method. ",				"",				"Main public API is ",				"\t- parse: aString"			],			"category" : "ClassParser-Parser"		},		"RBSimpleFormatter" : {			"hash" : 1187072,			"definition" : "RBProgramNodeVisitor subclass: #RBSimpleFormatter\r\tinstanceVariableNames: 'codeStream indent lineStart'\r\tclassVariableNames: 'FormatAsYouReadPolicy'\r\tpackage: 'AST-Core-Formatter'",			"comment" : [				"I'm a simple formatter that prints nodes (without using source code).",				"I'm useful when AST are programmatically assembled. ",				"",				"I could be improved, but the goal is to get the information is a more or less ok form."			],			"category" : "AST-Core-Formatter"		},		"TRBProgramNodeVisitor" : {			"hash" : 1318656,			"definition" : "Trait named: #TRBProgramNodeVisitor\r\tpackage: 'AST-Core-Traits'",			"comment" : [				"A TRBProgramNodeVisitor is a simple Trait that define visitor methods. "			],			"category" : "AST-Core-Traits"		},		"SHRBTextStyler" : {			"hash" : 3677952,			"definition" : "SHTextStyler subclass: #SHRBTextStyler\r\tuses: TRBProgramNodeVisitor\r\tinstanceVariableNames: 'charAttr parentheseLevel bracketLevel classOrMetaClass font isForWorkspace pixelHeight workspace'\r\tclassVariableNames: ''\r\tpackage: 'Shout-Styling'",			"comment" : [				"I'm the one who visits node to coloring the code"			],			"category" : "Shout-Styling"		},		"CDFluidClassDefinitionParser" : {			"hash" : 4325120,			"definition" : "CDAbstractClassDefinitionParser subclass: #CDFluidClassDefinitionParser\r\tinstanceVariableNames: 'subclass'\r\tclassVariableNames: ''\r\tpackage: 'ClassParser-Parser'",			"comment" : [				"I'm parser for the new class syntax. ",				"",				"",				"### The new syntax for class definition (just for the class and not for the methods) is",				"",				"```",				"Superclass < #MyObject",				"\tuses: #MyTrait;",				"\tslots: { #a. #b };",				"\tsharedVariables: { #A. #B };",				"\ttags: {'tag2' . 'Core'} ;",				"\tlayout: VariableLayout; ",				"\tsharedPools: { #TextConstants } ;",				"\tpackage: #MyPackage",				"```",				"Pay attention all the messages should be keyword-based.",				"",				"The minimal class definition is the following one: ",				"",				"```",				"Superclass < #MyObject",				"\tpackage: #MyPackage",				"```",				"",				"For the implementors, we see that we should either handle a simple message composition or a cascade. ",				"",				"### Design Concerns ",				"Note that sending a message to the superclass is close to subclass: and it lets the class selects ",				"a class definition parser if the syntax should be extended. ",				"In addition having a binary message makes () unneccessary.",				""			],			"category" : "ClassParser-Parser"		},		"OCASTMethodMetadataAnalyser" : {			"hash" : 1253120,			"definition" : "RBProgramNodeVisitor subclass: #OCASTMethodMetadataAnalyser\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-Semantics'",			"comment" : [				"This visitor analyses the AST and then adds annotations that will end up being set on the",				"compild method.",				"",				"One example are methods that contains message send that is a #halt (and any of it's variations)"			],			"category" : "OpalCompiler-Core-Semantics"		},		"CoASTHeuristicsResultSetBuilder" : {			"hash" : 5311488,			"definition" : "CoASTResultSetBuilder subclass: #CoASTHeuristicsResultSetBuilder\r\tinstanceVariableNames: 'messageHeuristic methodNodeHeuristic variablesHeuristic'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Model-SystemIntegration'",			"comment" : [				"I am the an AST based heuristics builder.",				"",				"When building the complishon, I build the AST from the source in the context, and get the current node from the context position.",				"Then I do a double dispatch on the current node and from it",				"1) I decide what fetchers to create",				"2) I extract the currently typed text and set is as initial filter"			],			"category" : "HeuristicCompletion-Model-SystemIntegration"		},		"CoASTResultSetBuilder" : {			"hash" : 5310976,			"definition" : "CoResultSetBuilder subclass: #CoASTResultSetBuilder\r\tinstanceVariableNames: 'astNode node'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Model-SystemIntegration'",			"comment" : [				"I'm an abstract superclass for defining AST Based Complishons"			],			"category" : "HeuristicCompletion-Model-SystemIntegration"		},		"RBProgramNodeVisitor" : {			"hash" : 1173504,			"definition" : "Object subclass: #RBProgramNodeVisitor\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Visitors'",			"comment" : [				"RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.",				""			],			"category" : "AST-Core-Visitors"		},		"RFASTTranslator" : {			"hash" : 3057408,			"definition" : "OCASTTranslator subclass: #RFASTTranslator\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Reflectivity-Compiler'",			"comment" : [				"subclass of Opal that takes links into account"			],			"category" : "Reflectivity-Compiler"		},		"RBProgramNodeIdentityVisitor" : {			"hash" : 2842880,			"definition" : "RBProgramNodeVisitor subclass: #RBProgramNodeIdentityVisitor\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-RB'",			"comment" : [				"I am a node program visitor that reconstruct an exact copy of the visited RBNode object."			],			"category" : "MicroKanren-RB"		},		"RBNode" : {			"hash" : 1177600,			"definition" : "Object subclass: #RBNode\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Nodes'",			"comment" : [				"I'm the superclass of the all the nodes for ",				"\t- expressions and methods (subclasses of RBProgramNode) - historically it was the only tree and ",				"\tit was the only part concerned with refactorings (hence the RB suffix for RegactoringBrowser).",				"\t- class definition (just nodes to represent the class creation messages),",				"\t- full program (class definitions or method definitions)",				"",				"In the future my prefix may change to convey the fact that my hierarchy is much more than supporting compiler and refactorings.",				"",				"I'm a new player in the field, do not hesitate to improve me."			],			"category" : "AST-Core-Nodes"		},		"RGTraitCompositionVisitor" : {			"hash" : 4823552,			"definition" : "RBProgramNodeVisitor subclass: #RGTraitCompositionVisitor\r\tinstanceVariableNames: 'traitComposition'\r\tclassVariableNames: ''\r\tpackage: 'Ring-Core-Parsing'",			"comment" : [				"ast := (RBParser parseExpression: 'Trait1 + Trait2 + Trait3 + Trait4').",				"ast := (RBParser parseExpression: '(Trait2 - {#c})').",				"ast := (RBParser parseExpression: 'Trait1 + (Trait2 - {#c})').",				"ast := (RBParser parseExpression: 'Trait1 + (Trait2 - {#c}) + Trait3').",				"ast := (RBParser parseExpression: 'Trait1 + (Trait2 - #(c ahoj bla: bla:bla:)) + Trait3').",				"",				"composition := RGTraitComposition unnamed.",				"",				"visitor := RGTraitCompositionVisitor new.",				"visitor traitComposition: composition.",				"ast acceptVisitor: visitor.",				"",				"",				"",				""			],			"category" : "Ring-Core-Parsing"		},		"RBParseTreeRewriter" : {			"hash" : 1196544,			"definition" : "RBParseTreeSearcher subclass: #RBParseTreeRewriter\r\tinstanceVariableNames: 'tree'\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Matching'",			"comment" : [				"ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then the answer is set to true, and the modified tree can be retrieved by the #tree method.",				"",				"",				"Here is a little script to rewrite a self halt into self dormantHalt. ",				"",				"\t| rewriter node |",				"\trewriter := RBParseTreeRewriter new.",				"\trewriter replace: 'self halt' with: 'self dormatHalt'.",				"\tnode := (ProtoObjectTest>>#testIfNil) parseTree.",				"\trewriter executeTree: node.",				"\t^ node formattedCode",				"",				"Note how do we get the transformed code. You can access the rewritten tree as follows:",				"rewriter tree.",				"",				"Now here is a full script showing how to compile the method back. ",				"",				"   | rewriter ok method |",				"\trewriter := RBParseTreeRewriter new.",				"\trewriter replaceMethod: self searchPattern with: self targetPattern.",				"\tmethod := (BIArrayExpressionTest>>#testNoExtraSpaceAroundPeriod).",				"\tok := rewriter executeTree: method parseTree.",				"\tok ifFalse: [ ^ 'did not work' ].",				"\tAuthor ",				"\t\tuseAuthor: 'Refactoring'",				"\t\tduring: [  ",				"\t\t\tmethod origin ",				"\t\t\t\tcompile: rewriter tree formattedCode ",				"\t\t\t\tclassified: method protocol ]",				"",				"",				"Have a look at the users of deprecated:",				"",				"\t\tdeprecated: 'Please use #isPinnedInMemory instead'",				"\t\ttransformWith: '`@receiver isPinned' -> '`@receiver isPinnedInMemory'.",				"",				"You can also have a look at the ParseTreeRewriterTest class.",				"",				"",				"Instance Variables:",				"\ttree\t<RBProgramNode>\tthe parse tree we're transforming",				"\t\t\t",				"\t"			],			"category" : "AST-Core-Matching"		},		"RBReadBeforeWrittenTester" : {			"hash" : 1182976,			"definition" : "RBProgramNodeVisitor subclass: #RBReadBeforeWrittenTester\r\tinstanceVariableNames: 'read checkNewTemps scopeStack'\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Visitors'",			"comment" : [				"RBReadBeforeWrittenTester is a visitor that identifies variables that may have been read before they are initialized.",				"",				"Instance Variables:",				"\tcheckNewTemps\t<Boolean>\tdescription of checkNewTemps",				"\tread\t<Collection>\tdescription of read",				"\tscopeStack\t<OrderedCollection>\tdescription of scopeStack",				""			],			"category" : "AST-Core-Visitors"		},		"CDTraitCompositionBuilder" : {			"hash" : 4336384,			"definition" : "Object subclass: #CDTraitCompositionBuilder\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'ClassParser-Model'",			"comment" : [				"I am in charge of building a Trait composition. ",				"",				"aTraitCompositionNode is composed of TraitNode."			],			"category" : "ClassParser-Model"		},		"RBProgramNodeSendsoVisitor" : {			"hash" : 2850304,			"definition" : "RBProgramNodeVisitor subclass: #RBProgramNodeSendsoVisitor\r\tinstanceVariableNames: 'goals selectorVar'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-RB'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tgoals:\t\t<Object>",				"\tselectorVar:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "MicroKanren-RB"		},		"CompiledMethod" : {			"hash" : 793344,			"definition" : "CompiledCode variableByteSubclass: #CompiledMethod\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Methods'",			"comment" : [				"Specific version of compiled code for method's.",				"",				"CompiledMethod instances can be in two forms:",				"- up until Pharo 6, they encode both the method and the inner closures bytecodes and literals.",				"- since Pharo 6, they encode only the method's bytecodes and literals.",				"",				"In addition the execution mechanics, a compiled method have two extra optional literals. The last literal, optional if there are no super sends, is the class in which the method is installed. The last but one literal is either the method's selector or an AdditionalMethodState instance. AdditionalMethodState instances are used to encode additional state to a method, as for example the pragmas.",				"",				"The bytecode encodes the trailer at the end, in most cases it has 4 bytes encoding the sourcer pointer (see CompiledMethodTrailer).",				"Thus endPC of a compiled method is not the size of the bytecode, but the size minus the length of the trailer."			],			"category" : "Kernel-Methods"		},		"CoTypeInferencer" : {			"hash" : 5316096,			"definition" : "Object subclass: #CoTypeInferencer\r\tinstanceVariableNames: 'returnType variables level arguments method temporaryVariables receiverClass argumentVariables'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Model-InitializeInferenceHeuristic'",			"comment" : [				"I am a simple type inferencer that is depth-bound.",				"That is, I infer a method up to a certain level of the callgraph."			],			"category" : "HeuristicCompletion-Model-InitializeInferenceHeuristic"		},		"RBDumpVisitor" : {			"hash" : 1184768,			"definition" : "RBProgramNodeVisitor subclass: #RBDumpVisitor\r\tinstanceVariableNames: 'stream'\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Visitors'",			"comment" : [				"I'm a visitor that generates code whose execution will recreate the visited node (similarly to storeOn: protocol).",				"This is handy because we can simply serialize the object in a textual form without requiring a separate parser.",				"",				"I'm used by reflexivity.",				"",				"try me! ",				"(RBDumpVisitor >> #stream) ast dump",				"",				"Instance Variables",				"\tstream:\t\t<Object>\t\tThe stream holding the output. Filled up throughout the visit.",				""			],			"category" : "AST-Core-Visitors"		},		"CoMockASTResultSetBuilder" : {			"hash" : 2866944,			"definition" : "CoASTResultSetBuilder subclass: #CoMockASTResultSetBuilder\r\tinstanceVariableNames: 'heuristic'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Tests-Core'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\theuristic:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "HeuristicCompletion-Tests-Core"		},		"EFFormatter" : {			"hash" : 3145984,			"definition" : "RBProgramNodeVisitor subclass: #EFFormatter\r\tinstanceVariableNames: 'codeStream indent originalSource lineStart context isInCascadeNode lookAheadCode'\r\tclassVariableNames: 'DefaultPrettyPrintContext FormatAsYouReadPolicy'\r\tpackage: 'EnlumineurFormatter-Core'",			"comment" : [				"Enlumineur is a replacement of BlueInk pretty printer (now packaged in pharo-contributions/configurableFormatter).",				"",				"It was developed by Hugo Lasnier during 6 months internship within RMOD and supervised by S. Ducasse and G. Polito during 2019.",				"The code was revisited and cleaned but there are probably more glitches left. ",				"",				"Enlumineur enhancements compared to BlueInk are:",				"",				"- systematic test coverage with more than 270 tests",				"- full revisiting of settings with description and examples",				"- no way to break the code by entering a non space character to indent code",				"- support for {.....} long list",				"- cleaning coupled settings",				"- support for to:do: block like statement (multiline arguments)",				"- removal of \"traditional parentheses\" whatever it meant.",				"- new line and more indentations after the opening bracket",				"- A dedicated UI was in preparation but should be redone before introduced in Pharo.",				" See package Enlumineur-UI (https://github.com/Ducasse/enlumineur)",				"",				"Enlumineur should be improved to be able to reformat the full code of Pharo.",				"The tests are a first step to make sure that we understand what is impacted by a change.",				"",				"Implementation remarks",				"\t  - willBeMultiline: too costly because it formats the code to see if it fits.",				"\tWe should have other heuristics.",				"\t- formatBlock: should be improved and speed up. ",				"\tformatBlock2: is a first alternative but it broke some tests that should be evaluated. ",				"\t- Some Node extensions should be pushed to the packages their belong to. "			],			"category" : "EnlumineurFormatter-Core"		},		"BlockClosure" : {			"hash" : 9472,			"definition" : "Object variableSubclass: #BlockClosure\r\tinstanceVariableNames: 'outerContext startpc numArgs'\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Methods'",			"comment" : [				"I contain a sequence of operations. I am defined by Smalltalk expressions inside square brackets. I permit to defer the enclosed operations until I execute a variant of #value. I can have my own arguments and temporaries as a regular method, but I am also able to use external variables: my enclosing method or block temporaries, arguments and receiver.",				"",				"examples :",				"[ 1 + 2 ] value",				"[ :arg | ",				"\t| temp | ",				"\ttemp := arg. ",				"\ttemp ] value: 5",				"[ ^ 5 ] value",				"",				"My return value corresponds to my final expression. A non local return (^) has the same effect as if I did not exist: it returns from my enclosing method, even if I'm nested in other blocks. ",				"",				"Implementation:",				"",				"Instance variables:",				"\touterContext <Context|nil> context that defined me",				"\tstartpc: <SmallInteger> (pc = program counter) offset of my first bytecode instruction in the compiledMethod bytecode  ",				"\tnumArgs: <SmallInteger> my number of arguments",				"",				"I am created at runtime through a special bytecode:",				"closureNumCopied: x numArgs: y bytes z1 to z2",				"On creation, the currently executed context is set to my outerContext, z1 is set as my startpc and y is set as my numArgs. After my creation, the current execution flow jumps to my last bytecode, z2, to skip the execution of my bytecode which is deferred until I execute a variant of #value.",				"",				"I am executed when I receive a variant of the message value. This message creates a new context, a block context <MethodContext>, which reference me in its variable closureOrNil. This new context executes my bytecode, which correspond to a subset of the bytecode of my enclosing method, starting at startpc and ending in blockReturn/return bytecode.",				"",				"Accessing variables of the my enclosing context is different depending on variables because of various optimizations:",				"- self: I access the receiver of my enclosing method by accessing my context's receiver, which is always set to the enclosing method receiver.",				"- copied variables: If I read a variable from an outerContext but I don't write into it and the variable is not modified after the BlockClosure creation, then the variable is copied in the blockClosure to be more efficient. ",				"- full variable: If I access and edit a variable from an outerContext, then the variable is stored in an external heap allocated array (named tempVector). The tempVector is known by the method and the block so they can both read and write these variables.",				"",				"Optimized block closures: ",				"Common blocks (2/3 of the blocks) are optimized directly in the compiler and have special behaviors. These blocks are the arguments/receiver of control structures: #ifNil:, #ifNotNil:, #ifTrue:, #ifFalse:, #whileTrue:, #whileFalse:, #to:do:, #to:by:do: ."			],			"category" : "Kernel-Methods"		},		"IconStyler" : {			"hash" : 2081536,			"definition" : "RBProgramNodeVisitor subclass: #IconStyler\r\tinstanceVariableNames: 'textModel stylerClasses'\r\tclassVariableNames: ''\r\tpackage: 'Reflectivity-Tools-Breakpoints'",			"comment" : [				"I'm in charge to styling an ast with highlighting. To highglight something I need the rubric text model in textModel."			],			"category" : "Reflectivity-Tools-Breakpoints"		}	},	"messages" : {		"testSenderoForBlockClosure" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			],			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"testSenderoForBlockClosure",						"",						"\t| aBlock |",						"\taBlock := [ :aMessageNode :goals :selectorVar | ",						"\t          super visitMessageNode: aMessageNode.",						"\t          goals add:",						"\t\t          (selectorVar unifyo value: aMessageNode selectorNode) ].",						"\tself",						"\t\tassert:",						"\t\t[ :selector | aBlock sendso value: selector ] asGoal solutions",						"\t\tequals: { ",						"\t\t\t\t(RBSelectorNode value: #visitMessageNode:).",						"\t\t\t\t(RBSelectorNode value: #unifyo).",						"\t\t\t\t(RBSelectorNode value: #selectorNode).",						"\t\t\t\t(RBSelectorNode value: #value:).",						"\t\t\t\t(RBSelectorNode value: #add:) }",						"\t\tmodulo: #asOrderedCollection.",						"",						"\tself deny: (super respondsTo: #visitMessageNode:)"					],					"body" : [						"| aBlock |",						"aBlock := [ :aMessageNode :goals :selectorVar | ",						"          super visitMessageNode: aMessageNode.",						"          goals add:",						"\t          (selectorVar unifyo value: aMessageNode selectorNode) ].",						"self",						"\tassert:",						"\t[ :selector | aBlock sendso value: selector ] asGoal solutions",						"\tequals: { ",						"\t\t\t(RBSelectorNode value: #visitMessageNode:).",						"\t\t\t(RBSelectorNode value: #unifyo).",						"\t\t\t(RBSelectorNode value: #selectorNode).",						"\t\t\t(RBSelectorNode value: #value:).",						"\t\t\t(RBSelectorNode value: #add:) }",						"\tmodulo: #asOrderedCollection.",						"",						"self deny: (super respondsTo: #visitMessageNode:)"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4440752,					"argumentNames" : [ ]				}			}		},		"testSenderoForCompiledMethod" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			],			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"testSenderoForCompiledMethod",						"",						"\tself",						"\t\tassert: [ :selector | ",						"\t\t\t(RBProgramNodeSendsoVisitor >> #visitMessageNode:) sendso value:",						"\t\t\t\tselector ] asGoal solutions",						"\t\tequals: { ",						"\t\t\t\t(RBSelectorNode value: #visitMessageNode:).",						"\t\t\t\t(RBSelectorNode value: #unifyo).",						"\t\t\t\t(RBSelectorNode value: #selectorNode).",						"\t\t\t\t(RBSelectorNode value: #value:).",						"\t\t\t\t(RBSelectorNode value: #add:) }",						"\t\tmodulo: #asOrderedCollection"					],					"body" : [						"self",						"\tassert: [ :selector | ",						"\t\t(RBProgramNodeSendsoVisitor >> #visitMessageNode:) sendso value:",						"\t\t\tselector ] asGoal solutions",						"\tequals: { ",						"\t\t\t(RBSelectorNode value: #visitMessageNode:).",						"\t\t\t(RBSelectorNode value: #unifyo).",						"\t\t\t(RBSelectorNode value: #selectorNode).",						"\t\t\t(RBSelectorNode value: #value:).",						"\t\t\t(RBSelectorNode value: #add:) }",						"\tmodulo: #asOrderedCollection"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4177107,					"argumentNames" : [ ]				}			}		},		"sendso" : {			"implementors" : {				"RBNode" : {					"sourceCode" : [						"sendso",						"",						"\t^ [ :anObject | ",						"\t  RBProgramNodeSendsoVisitor new",						"\t\t  selectorVar: anObject;",						"\t\t  visitNode: self;",						"\t\t  asGoal ]"					],					"body" : [						"^ [ :anObject | ",						"  RBProgramNodeSendsoVisitor new",						"\t  selectorVar: anObject;",						"\t  visitNode: self;",						"\t  asGoal ]"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 1971357,					"argumentNames" : [ ]				},				"BlockClosure" : {					"sourceCode" : [						"sendso",						"",						"\t^ self sourceNode body sendso"					],					"body" : [						"^ self sourceNode body sendso"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 803478,					"argumentNames" : [ ]				},				"CompiledMethod" : {					"sourceCode" : [						"sendso",						"",						"\t^ self sourceNode body sendso"					],					"body" : [						"^ self sourceNode body sendso"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 1587350,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#sendso",				"CompiledMethod>>#sendso",				"RBNodePredicatesTest>>#testSenderoForCompiledMethod",				"RBNodePredicatesTest>>#testSenderoBackwards",				"RBNodePredicatesTest>>#testSenderoForBlockClosure"			]		},		"testSenderoBackwards" : {			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"testSenderoBackwards",						"",						"\tself",						"\t\tassert: ([ :aSend | ",						"\t\t\t [ :o | o ] rbo: [ :ast | [ :o | ast sendso value: aSend ] ] ]",						"\t\t\t\t asGoal solutions next: 5)",						"\t\tequals: { ",						"\t\t\t\t(RBMessageNode",						"\t\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t\t selector: #numberOfEdges).",						"\t\t\t\t(RBMessageNode",						"\t\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t\t selector: #testStackedVertically).",						"\t\t\t\t(RBMessageNode",						"\t\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t\t selector: #iconicHaloSpecifications).",						"\t\t\t\t(RBMessageNode",						"\t\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t\t selector: #packageModels).",						"\t\t\t\t(RBMessageNode",						"\t\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t\t selector: #testReversed) }",						"\t\tmodulo: #asOrderedCollection"					],					"body" : [						"self",						"\tassert: ([ :aSend | ",						"\t\t [ :o | o ] rbo: [ :ast | [ :o | ast sendso value: aSend ] ] ]",						"\t\t\t asGoal solutions next: 5)",						"\tequals: { ",						"\t\t\t(RBMessageNode",						"\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t selector: #numberOfEdges).",						"\t\t\t(RBMessageNode",						"\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t selector: #testStackedVertically).",						"\t\t\t(RBMessageNode",						"\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t selector: #iconicHaloSpecifications).",						"\t\t\t(RBMessageNode",						"\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t selector: #packageModels).",						"\t\t\t(RBMessageNode",						"\t\t\t\t receiver: (RBVariableNode named: #x)",						"\t\t\t\t selector: #testReversed) }",						"\tmodulo: #asOrderedCollection"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4175977,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			]		},		"visitMessageNode:" : {			"implementors" : {				"RBDumpVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tstream",						"\t\tnextPutAll: aMessageNode class name;",						"\t\tnextPutAll: ' receiver: ('.",						"\taMessageNode receiver acceptVisitor: self.",						"\tstream nextPutAll: ') selector: '.",						"\taMessageNode selector printOn: stream.",						"\taMessageNode arguments ifNotEmpty: [ ",						"\t\tstream nextPutAll: ' arguments: {'.",						"\t\taMessageNode arguments do: [ :each | ",						"\t\t\teach acceptVisitor: self.",						"\t\t\tstream nextPutAll: '. ' ].",						"\t\tstream nextPut: $} ]"					],					"body" : [						"stream",						"\tnextPutAll: aMessageNode class name;",						"\tnextPutAll: ' receiver: ('.",						"aMessageNode receiver acceptVisitor: self.",						"stream nextPutAll: ') selector: '.",						"aMessageNode selector printOn: stream.",						"aMessageNode arguments ifNotEmpty: [ ",						"\tstream nextPutAll: ' arguments: {'.",						"\taMessageNode arguments do: [ :each | ",						"\t\teach acceptVisitor: self.",						"\t\tstream nextPutAll: '. ' ].",						"\tstream nextPut: $} ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19021511,					"argumentNames" : [						"aMessageNode"					]				},				"IconStyler" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tself addIconStyle: aMessageNode.",						"\tsuper visitMessageNode: aMessageNode"					],					"body" : [						"self addIconStyle: aMessageNode.",						"super visitMessageNode: aMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19915523,					"argumentNames" : [						"aMessageNode"					]				},				"CDFluidClassDefinitionParser" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t\"See class comment. Here we handle the cascade version of the class definition.\"",						"",						"\t\"",						"\tObject << #Point",						"\t\t\tpackage: ''Kernel-BasicObjects'''",						"\t\"",						"",						"\tself handleClassAndSuperclassOf: aRBMessageNode.",						"",						"",						"\taRBMessageNode selectorParts",						"\t\twith: aRBMessageNode arguments",						"\t\tdo: [ :selectorPart :argument | ",						"\t\t\tself parseSelectorPart: selectorPart withArgument: argument ]"					],					"body" : [						"self handleClassAndSuperclassOf: aRBMessageNode.",						"",						"",						"aRBMessageNode selectorParts",						"\twith: aRBMessageNode arguments",						"\tdo: [ :selectorPart :argument | ",						"\t\tself parseSelectorPart: selectorPart withArgument: argument ]"					],					"isTestMethod" : false,					"category" : "parsing-internal",					"comment" : [						"See class comment. Here we handle the cascade version of the class definition."					],					"hash" : 22159581,					"argumentNames" : [						"aRBMessageNode"					]				},				"RFASTTranslator" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\taMessageNode isInlined",						"\t\tifTrue: [ ",						"\t\t\tmethodBuilder addLiteral: aMessageNode selector. \"so searching for senders will work\"",						"\t\t\tself emitPreamble: aMessageNode.",						"\t\t\tself emitMetaLinkBefore: aMessageNode.",						"\t\t\taMessageNode hasMetalinkInstead",						"\t\t\t\tifTrue: [ self emitMetaLinkInstead: aMessageNode ]",						"\t\t\t\tifFalse: [ ",						"\t\t\t\t\tself",						"\t\t\t\t\t\tperform: (OptimizedMessages at: aMessageNode selector)",						"\t\t\t\t\t\twith: aMessageNode ].",						"\t\t\tself emitMetaLinkAfterNoEnsure: aMessageNode ]",						"\t\tifFalse: [ self emitMessageNode: aMessageNode ]"					],					"body" : [						"aMessageNode isInlined",						"\tifTrue: [ ",						"\t\tmethodBuilder addLiteral: aMessageNode selector. \"so searching for senders will work\"",						"\t\tself emitPreamble: aMessageNode.",						"\t\tself emitMetaLinkBefore: aMessageNode.",						"\t\taMessageNode hasMetalinkInstead",						"\t\t\tifTrue: [ self emitMetaLinkInstead: aMessageNode ]",						"\t\t\tifFalse: [ ",						"\t\t\t\tself",						"\t\t\t\t\tperform: (OptimizedMessages at: aMessageNode selector)",						"\t\t\t\t\twith: aMessageNode ].",						"\t\tself emitMetaLinkAfterNoEnsure: aMessageNode ]",						"\tifFalse: [ self emitMessageNode: aMessageNode ]"					],					"isTestMethod" : false,					"category" : "visitor-double dispatching",					"comment" : [ ],					"hash" : 20893190,					"argumentNames" : [						"aMessageNode"					]				},				"RBParseTreeRewriter" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\taMessageNode receiver: (self visitNode: aMessageNode receiver).",						"\taMessageNode arguments:",						"\t\t(aMessageNode arguments collect: [ :each | self visitNode: each ])"					],					"body" : [						"aMessageNode receiver: (self visitNode: aMessageNode receiver).",						"aMessageNode arguments:",						"\t(aMessageNode arguments collect: [ :each | self visitNode: each ])"					],					"isTestMethod" : false,					"category" : "visitor-double dispatching",					"comment" : [ ],					"hash" : 19031389,					"argumentNames" : [						"aMessageNode"					]				},				"RBProgramNodeVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\tifTrue: [ self visitNode: aMessageNode receiver ].",						"\taMessageNode arguments do: [ :each | self visitNode: each ]"					],					"body" : [						"(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\tifTrue: [ self visitNode: aMessageNode receiver ].",						"aMessageNode arguments do: [ :each | self visitNode: each ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19009106,					"argumentNames" : [						"aMessageNode"					]				},				"FBDOptimizedMessagesRewriter" : {					"sourceCode" : [						"visitMessageNode: msgNode",						"",						"\t\"Do not add return statements. ",						"\tifTrue:ifFalse: handling may change the current message node into an ifTrue: , an ifFalse: or an ifNil:ifNotNil: message. ",						"\twhileTrue are used to detect to:do: and to: by: do.\"",						"",						"\tsuper visitMessageNode: msgNode.",						"\t(self isReconstructed: msgNode) ifFalse: [ ^ self ].",						"\tmsgNode selector = #ifTrue:ifFalse: ifTrue: [ ",						"\t\tself handleIfTrueIfFalse: msgNode ].",						"\tmsgNode selector = #ifNil:ifNotNil: ifTrue: [ ",						"\t\tself handleIfNilIfNotNil: msgNode ].",						"\tmsgNode selector = #ifTrue: ifTrue: [ self handleIfTrue: msgNode ].",						"\tmsgNode selector = #ifFalse: ifTrue: [ self handleIfFalse: msgNode ].",						"\tmsgNode selector = #whileTrue: ifTrue: [ ",						"\t\tself handleWhileTrue: msgNode ].",						"\t(self isBigArray: msgNode) ifTrue: [ self handleBigArray: msgNode ]"					],					"body" : [						"super visitMessageNode: msgNode.",						"(self isReconstructed: msgNode) ifFalse: [ ^ self ].",						"msgNode selector = #ifTrue:ifFalse: ifTrue: [ ",						"\tself handleIfTrueIfFalse: msgNode ].",						"msgNode selector = #ifNil:ifNotNil: ifTrue: [ ",						"\tself handleIfNilIfNotNil: msgNode ].",						"msgNode selector = #ifTrue: ifTrue: [ self handleIfTrue: msgNode ].",						"msgNode selector = #ifFalse: ifTrue: [ self handleIfFalse: msgNode ].",						"msgNode selector = #whileTrue: ifTrue: [ ",						"\tself handleWhileTrue: msgNode ].",						"(self isBigArray: msgNode) ifTrue: [ self handleBigArray: msgNode ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [						"Do not add return statements. ",						"\tifTrue:ifFalse: handling may change the current message node into an ifTrue: , an ifFalse: or an ifNil:ifNotNil: message. ",						"\twhileTrue are used to detect to:do: and to: by: do."					],					"hash" : 19503619,					"argumentNames" : [						"msgNode"					]				},				"CoMockASTResultSetBuilder" : {					"sourceCode" : [						"visitMessageNode: aNode",						"",						"\theuristic := #message.",						"\t^ super visitMessageNode: aNode"					],					"body" : [						"heuristic := #message.",						"^ super visitMessageNode: aNode"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20700451,					"argumentNames" : [						"aNode"					]				},				"RBProgramNodeSendsoVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tsuper visitMessageNode: aMessageNode.",						"",						"\tgoals add: (selectorVar unifyo value: aMessageNode selectorNode)"					],					"body" : [						"super visitMessageNode: aMessageNode.",						"",						"goals add: (selectorVar unifyo value: aMessageNode selectorNode)"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20684630,					"argumentNames" : [						"aMessageNode"					]				},				"EFFormatter" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tself visitNode: aMessageNode receiver.",						"\tself formatSelectorAndArguments: aMessageNode"					],					"body" : [						"self visitNode: aMessageNode receiver.",						"self formatSelectorAndArguments: aMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20980019,					"argumentNames" : [						"aMessageNode"					]				},				"CDTraitCompositionBuilder" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t| node receiver argument |",						"\taRBMessageNode selector = #classTrait ifTrue: [ ",						"\t\t^ CDClassTraitNode new",						"\t\t\t  originalNode: aRBMessageNode;",						"\t\t\t  name: aRBMessageNode receiver name;",						"\t\t\t  yourself ].",						"",						"\treceiver := aRBMessageNode receiver acceptVisitor: self.",						"\targument := aRBMessageNode arguments first acceptVisitor: self.",						"",						"\tnode := receiver perform: aRBMessageNode selector with: argument.",						"\tnode originalNode: aRBMessageNode.",						"\t^ node"					],					"body" : [						"| node receiver argument |",						"aRBMessageNode selector = #classTrait ifTrue: [ ",						"\t^ CDClassTraitNode new",						"\t\t  originalNode: aRBMessageNode;",						"\t\t  name: aRBMessageNode receiver name;",						"\t\t  yourself ].",						"",						"receiver := aRBMessageNode receiver acceptVisitor: self.",						"argument := aRBMessageNode arguments first acceptVisitor: self.",						"",						"node := receiver perform: aRBMessageNode selector with: argument.",						"node originalNode: aRBMessageNode.",						"^ node"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 22958405,					"argumentNames" : [						"aRBMessageNode"					]				},				"CoTypeInferencer" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t| receiverType |",						"\treceiverType := aRBMessageNode receiver acceptVisitor: self.",						"\t^ self visitMessageNode: aRBMessageNode receiverType: receiverType"					],					"body" : [						"| receiverType |",						"receiverType := aRBMessageNode receiver acceptVisitor: self.",						"^ self visitMessageNode: aRBMessageNode receiverType: receiverType"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23412137,					"argumentNames" : [						"aRBMessageNode"					]				},				"RBSimpleFormatter" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tself",						"\t\tvisitNode: aMessageNode receiver;",						"\t\tformatSelectorAndArguments: aMessageNode"					],					"body" : [						"self",						"\tvisitNode: aMessageNode receiver;",						"\tformatSelectorAndArguments: aMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19021114,					"argumentNames" : [						"aMessageNode"					]				},				"CDClassDefinitionParser" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t(self isInstanceSideDefinition: aRBMessageNode)",						"\t\tifTrue: [ self handleSuperclassNode: aRBMessageNode receiver ]",						"\t\tifFalse: [ self handleClassName: aRBMessageNode receiver receiver ].",						"",						"\taRBMessageNode selectorParts",						"\t\twith: aRBMessageNode arguments",						"\t\tdo: [ :selectorPart :argument | ",						"\t\t\tself parseSelectorPart: selectorPart withArgument: argument ]"					],					"body" : [						"(self isInstanceSideDefinition: aRBMessageNode)",						"\tifTrue: [ self handleSuperclassNode: aRBMessageNode receiver ]",						"\tifFalse: [ self handleClassName: aRBMessageNode receiver receiver ].",						"",						"aRBMessageNode selectorParts",						"\twith: aRBMessageNode arguments",						"\tdo: [ :selectorPart :argument | ",						"\t\tself parseSelectorPart: selectorPart withArgument: argument ]"					],					"isTestMethod" : false,					"category" : "parsing",					"comment" : [ ],					"hash" : 22160715,					"argumentNames" : [						"aRBMessageNode"					]				},				"CoASTHeuristicsResultSetBuilder" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t^ self",						"\t\t  configureFetcherForNode: aRBMessageNode",						"\t\t  usingHeuristicAvoidingRepetitions: self messageHeuristic"					],					"body" : [						"^ self",						"\t  configureFetcherForNode: aRBMessageNode",						"\t  usingHeuristicAvoidingRepetitions: self messageHeuristic"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23144880,					"argumentNames" : [						"aRBMessageNode"					]				},				"OCASTTranslator" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\taMessageNode isInlined ifTrue: [ ",						"\t\tmethodBuilder addLiteral: aMessageNode selector. \"so searching for senders will work\"",						"\t\t^ self",						"\t\t\t  perform: (OptimizedMessages at: aMessageNode selector)",						"\t\t\t  with: aMessageNode ].",						"\t^ self emitMessageNode: aMessageNode"					],					"body" : [						"aMessageNode isInlined ifTrue: [ ",						"\tmethodBuilder addLiteral: aMessageNode selector. \"so searching for senders will work\"",						"\t^ self",						"\t\t  perform: (OptimizedMessages at: aMessageNode selector)",						"\t\t  with: aMessageNode ].",						"^ self emitMessageNode: aMessageNode"					],					"isTestMethod" : false,					"category" : "visitor-double dispatching",					"comment" : [ ],					"hash" : 19083763,					"argumentNames" : [						"aMessageNode"					]				},				"CoASTResultSetBuilder" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t^ self visitNode: aRBMessageNode"					],					"body" : [						"^ self visitNode: aRBMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23144128,					"argumentNames" : [						"aRBMessageNode"					]				},				"OCASTMethodMetadataAnalyser" : {					"sourceCode" : [						"visitMessageNode: aNode",						"",						"\tsuper visitMessageNode: aNode.",						"\taNode isHaltNode ifTrue: [ ",						"\t\taNode methodNode methodPropertyAt: #containsHalt put: true ]"					],					"body" : [						"super visitMessageNode: aNode.",						"aNode isHaltNode ifTrue: [ ",						"\taNode methodNode methodPropertyAt: #containsHalt put: true ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19087748,					"argumentNames" : [						"aNode"					]				},				"RGTraitCompositionVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t| rec args |",						"\trec := self visitNode: aMessageNode receiver.",						"\targs := aMessageNode arguments collect: [ :each | ",						"\t\t        self visitNode: each ].",						"",						"\taMessageNode selector = #+ ifTrue: [ ",						"\t\trec isCollection",						"\t\t\tifTrue: [ rec add: args first ]",						"\t\t\tifFalse: [ ",						"\t\t\t\trec := { ",						"\t\t\t\t\t       rec.",						"\t\t\t\t\t       args first } asOrderedCollection ].",						"\t\t^ rec ].",						"",						"\taMessageNode selector = #- ifTrue: [ ",						"\t\t| exclusion |",						"\t\texclusion := RGTraitExclusion parent: self traitComposition.",						"\t\texclusion pvtSubject: rec.",						"\t\texclusion pvtCleanExclusions.",						"\t\targs first do: [ :each | exclusion pvtAddExclusion: each ].",						"\t\t^ exclusion ].",						"",						"\t\"an Array(Trait2 @ {#c3->#c2})\"",						"\taMessageNode selector = #@ ifTrue: [ ",						"\t\t| exclusion |",						"\t\texclusion := RGTraitAlias parent: self traitComposition.",						"\t\texclusion pvtSubject: rec.",						"\t\texclusion pvtCleanAliases.",						"\t\targs first do: [ :each | exclusion pvtAddAlias: each ].",						"\t\t^ exclusion ].",						"",						"\taMessageNode selector = #-> ifTrue: [ \"for associations in aliases\" ",						"\t\t^ rec -> args first ].",						"",						"\taMessageNode selector = #classTrait ifTrue: [ \"for associations in aliases\"",						"\t\trec classTrait makeResolved.",						"\t\trec classTrait name: rec name , ' classTrait'.",						"\t\t^ rec classTrait ].",						"",						"\tself error: 'Unknown trait composition message'"					],					"body" : [						"| rec args |",						"rec := self visitNode: aMessageNode receiver.",						"args := aMessageNode arguments collect: [ :each | ",						"\t        self visitNode: each ].",						"",						"aMessageNode selector = #+ ifTrue: [ ",						"\trec isCollection",						"\t\tifTrue: [ rec add: args first ]",						"\t\tifFalse: [ ",						"\t\t\trec := { ",						"\t\t\t\t       rec.",						"\t\t\t\t       args first } asOrderedCollection ].",						"\t^ rec ].",						"",						"aMessageNode selector = #- ifTrue: [ ",						"\t| exclusion |",						"\texclusion := RGTraitExclusion parent: self traitComposition.",						"\texclusion pvtSubject: rec.",						"\texclusion pvtCleanExclusions.",						"\targs first do: [ :each | exclusion pvtAddExclusion: each ].",						"\t^ exclusion ].",						"",						"\"an Array(Trait2 @ {#c3->#c2})\"",						"aMessageNode selector = #@ ifTrue: [ ",						"\t| exclusion |",						"\texclusion := RGTraitAlias parent: self traitComposition.",						"\texclusion pvtSubject: rec.",						"\texclusion pvtCleanAliases.",						"\targs first do: [ :each | exclusion pvtAddAlias: each ].",						"\t^ exclusion ].",						"",						"aMessageNode selector = #-> ifTrue: [ \"for associations in aliases\" ",						"\t^ rec -> args first ].",						"",						"aMessageNode selector = #classTrait ifTrue: [ \"for associations in aliases\"",						"\trec classTrait makeResolved.",						"\trec classTrait name: rec name , ' classTrait'.",						"\t^ rec classTrait ].",						"",						"self error: 'Unknown trait composition message'"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23446276,					"argumentNames" : [						"aMessageNode"					]				},				"SHRBTextStyler" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t| style link |",						"\tstyle := #keyword.",						"",						"\t(Symbol findInternedSelector: aMessageNode selector asString) ifNil: [ ",						"\t\tstyle := self formatIncompleteSelector: aMessageNode ].",						"",						"\tlink := TextMethodLink sourceNode: aMessageNode.",						"\tself styleOpenParenthese: aMessageNode.",						"",						"\taMessageNode selectorParts",						"\t\twith: aMessageNode keywordsPositions",						"\t\tdo: [ :keyword :position | ",						"\t\t\tself",						"\t\t\t\taddStyle: style",						"\t\t\t\tattribute: link",						"\t\t\t\tfrom: position",						"\t\t\t\tto: position + keyword size - 1 ].",						"",						"\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\tifTrue: [ self visitNode: aMessageNode receiver ].",						"",						"\taMessageNode arguments do: [ :each | self visitNode: each ].",						"\tself styleCloseParenthese: aMessageNode"					],					"body" : [						"| style link |",						"style := #keyword.",						"",						"(Symbol findInternedSelector: aMessageNode selector asString) ifNil: [ ",						"\tstyle := self formatIncompleteSelector: aMessageNode ].",						"",						"link := TextMethodLink sourceNode: aMessageNode.",						"self styleOpenParenthese: aMessageNode.",						"",						"aMessageNode selectorParts",						"\twith: aMessageNode keywordsPositions",						"\tdo: [ :keyword :position | ",						"\t\tself",						"\t\t\taddStyle: style",						"\t\t\tattribute: link",						"\t\t\tfrom: position",						"\t\t\tto: position + keyword size - 1 ].",						"",						"(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\tifTrue: [ self visitNode: aMessageNode receiver ].",						"",						"aMessageNode arguments do: [ :each | self visitNode: each ].",						"self styleCloseParenthese: aMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 22037664,					"argumentNames" : [						"aMessageNode"					]				},				"TRBProgramNodeVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\tifTrue: [ self visitNode: aMessageNode receiver ].",						"\taMessageNode arguments do: [ :each | self visitNode: each ]"					],					"body" : [						"(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\tifTrue: [ self visitNode: aMessageNode receiver ].",						"aMessageNode arguments do: [ :each | self visitNode: each ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19154258,					"argumentNames" : [						"aMessageNode"					]				},				"RBReadBeforeWrittenTester" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t((#( #whileTrue: #whileFalse: #whileTrue #whileFalse #whileNil: ) ",						"\t\t  includes: aMessageNode selector) and: [ ",						"\t\t aMessageNode receiver isBlock ])",						"\t\tifTrue: [ self executeTree: aMessageNode receiver body ]",						"\t\tifFalse: [ ",						"\t\t\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\t\t\tifTrue: [ self visitNode: aMessageNode receiver ] ].",						"\t((#( #ifTrue:ifFalse: #ifFalse:ifTrue: ) includes:",						"\t\t  aMessageNode selector) and: [ ",						"\t\t aMessageNode arguments allSatisfy: [ :each | each isBlock ] ]) ",						"\t\tifTrue: [ ^ self processIfTrueIfFalse: aMessageNode ].",						"\taMessageNode arguments do: [ :each | self visitNode: each ]"					],					"body" : [						"((#( #whileTrue: #whileFalse: #whileTrue #whileFalse #whileNil: ) ",						"\t  includes: aMessageNode selector) and: [ ",						"\t aMessageNode receiver isBlock ])",						"\tifTrue: [ self executeTree: aMessageNode receiver body ]",						"\tifFalse: [ ",						"\t\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\t\tifTrue: [ self visitNode: aMessageNode receiver ] ].",						"((#( #ifTrue:ifFalse: #ifFalse:ifTrue: ) includes:",						"\t  aMessageNode selector) and: [ ",						"\t aMessageNode arguments allSatisfy: [ :each | each isBlock ] ]) ",						"\tifTrue: [ ^ self processIfTrueIfFalse: aMessageNode ].",						"aMessageNode arguments do: [ :each | self visitNode: each ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19019901,					"argumentNames" : [						"aMessageNode"					]				},				"RBProgramNodeIdentityVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t^ RBMessageNode",						"\t\t  receiver: (aMessageNode receiver acceptVisitor: self)",						"\t\t  selector: aMessageNode selector",						"\t\t  keywordsPositions: aMessageNode keywordsPositions",						"\t\t  arguments:",						"\t\t  (aMessageNode arguments collect: [ :aNode | ",						"\t\t\t   aNode acceptVisitor: self ])"					],					"body" : [						"^ RBMessageNode",						"\t  receiver: (aMessageNode receiver acceptVisitor: self)",						"\t  selector: aMessageNode selector",						"\t  keywordsPositions: aMessageNode keywordsPositions",						"\t  arguments:",						"\t  (aMessageNode arguments collect: [ :aNode | ",						"\t\t   aNode acceptVisitor: self ])"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20677625,					"argumentNames" : [						"aMessageNode"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"CoMockASTResultSetBuilder>>#visitMessageNode:",				"FBDOptimizedMessagesRewriter>>#visitMessageNode:",				"IconStyler>>#visitMessageNode:",				"OCASTMethodMetadataAnalyser>>#visitMessageNode:",				"RBMessageNode>>#acceptVisitor:",				"RBNodePredicatesTest>>#testSenderoForCompiledMethod",				"RBNodePredicatesTest>>#testSenderoForBlockClosure",				"RBProgramNodeSendsoVisitor>>#visitMessageNode:"			]		}	}}