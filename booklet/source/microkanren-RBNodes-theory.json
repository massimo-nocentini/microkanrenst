{	"classes" : {		"SycSourceCodeCommand" : {			"hash" : 2308096,			"definition" : "CmdCommand subclass: #SycSourceCodeCommand\r\tinstanceVariableNames: 'method sourceNode'\r\tclassVariableNames: ''\r\tpackage: 'SystemCommands-SourceCodeCommands'",			"comment" : [				"I am a base class for commands which perform operations with particular ast-node of given method.",				"  ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tmethod:\t\t<CompiledMethod>",				"\tsourceNode:\t\t<RBProgramNode>"			],			"category" : "SystemCommands-SourceCodeCommands"		},		"RBNodePredicatesTest" : {			"hash" : 3380992,			"definition" : "Srfi41AbstractTest subclass: #RBNodePredicatesTest\r\tuses: TIceImagesExporting\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-Tests'",			"comment" : [				"This class contains tests"			],			"category" : "MicroKanren-Tests"		},		"OCASTMethodMetadataAnalyser" : {			"hash" : 1253120,			"definition" : "RBProgramNodeVisitor subclass: #OCASTMethodMetadataAnalyser\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-Semantics'",			"comment" : [				"This visitor analyses the AST and then adds annotations that will end up being set on the",				"compild method.",				"",				"One example are methods that contains message send that is a #halt (and any of it's variations)"			],			"category" : "OpalCompiler-Core-Semantics"		},		"TextMethodLink" : {			"hash" : 1904896,			"definition" : "TextLink subclass: #TextMethodLink\r\tinstanceVariableNames: 'selector browseSenders sourceNode'\r\tclassVariableNames: ''\r\tpackage: 'Text-Core-Attributes'",			"comment" : [				"An active link in a text linking to a method"			],			"category" : "Text-Core-Attributes"		},		"IRInstruction" : {			"hash" : 1249024,			"definition" : "Object subclass: #IRInstruction\r\tinstanceVariableNames: 'sourceNode bytecodeIndex sequence'\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-IR-Nodes'",			"comment" : [				"I am an instruction in the IR (intermediate representation) language.  The IR serves as the intermediary between the Smalltalk language and the bytecode language.  It is easier to optimize and translate to/from this language than it is to optimize/translate directly from Smalltalk to bytecodes.  The IR is generic and simple consisting of just twelve instructions.  They are:",				"",				"\tgoto: labelNum",				"\tif: boolean goto: labelNum1 otherwise: labelNum2",				"\tlabel: labelNum",				"\tpopTop",				"\tpushDup",				"\tpushLiteral: object",				"\tpushTemp: name",				"\tblockReturn",				"\treturnTop",				"\tsend: selector",				"\tsend: selector toSuperOf: behavior",				"\tstoreTemp: name",				"",				"Each instruction is reified as an instance of one of my subclasses and grouped by basic block (IRSequence) into an IRMethod.  IRInterpreter visits each instruction in a IRMethod responding to the above instruction messages sent to it."			],			"category" : "OpalCompiler-Core-IR-Nodes"		},		"Object" : {			"hash" : 804608,			"definition" : "ProtoObject subclass: #Object\r\tinstanceVariableNames: ''\r\tclassVariableNames: 'DependentsFields'\r\tpackage: 'Kernel-Objects'",			"comment" : [				"`Object` is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.",				"",				"Class `Object` provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.",				"",				"`Object` has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.",				"",				"Class Variables:",				"\tDependentsFields\t\tan IdentityDictionary",				"\t\tProvides a virtual 'dependents' field so that any object may have one",				"\t\tor more dependent views, synchronized by the changed:/update: protocol.",				"\t\tNote that class Model has a real slot for its dependents, and overrides",				"\t\tthe associated protocol with more efficient implementations.",				"",				"Because `Object` is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.",				"",				"",				"###Miscellanous Discussions",				"",				"About `at:` index accepting float and not only integers",				" ",				"This behavior is also free in the sense that the failure code is only invoked when the primitive fails and so adds nothing to the cost of successful accesses, which are the high dynamic frequency operation.  It will also show up under",				"profiling if one is concerned about efficiency, and so isn't a hidden cost.",				"",				"It is also in keeping with Pharo's mixed mode/arbitrary precision",				"implicit coercion number system that one *can* use fractions or floats as",				"indices.  Stripping out coercions like this will make the system more brittle.  So ",				"please do *not* remove this hack.  I think it's a feature and a useful one.",				"",				"Can you give me an example that demonstrates the usefulness of this feature?",				"",				"```",				"| a r |",				"a := Array new: 10 withAll: 0.",				"r := Random new.",				"100 timesRepeat: [| v | v := r next * 10 + 1. a at: v put: (a at: v) + 1].",				"a",				"```",				"",				"i.e. I didn't have to provide an explicit rounding step.  That's useful.  But in general anywhere ",				"where an index is derived by some calculation not having to provide the rounding step could be ",				"useful/helpful/more concise.  e.g. (n roundTo: 0.1) * 10 vs ((n roundTo: 0.1) * 10) asInteger.",				"",				"Some thought went into the original choice.  It is not a hack but there by intent.  The integers are ",				"simply a subset of the reals and forcing the programmer to use them is favouring the machine ",				"above the programmer.",				"",				"But I think you should justify getting rid of it rather than my having to justify keeping it.  Getting ",				"rid of it risks breaking code.  If it is there but does not harm then why get rid of it?",				"",				"best Eliot Miranda "			],			"category" : "Kernel-Objects"		},		"RBSimpleFormatter" : {			"hash" : 1187072,			"definition" : "RBProgramNodeVisitor subclass: #RBSimpleFormatter\r\tinstanceVariableNames: 'codeStream indent lineStart'\r\tclassVariableNames: 'FormatAsYouReadPolicy'\r\tpackage: 'AST-Core-Formatter'",			"comment" : [				"I'm a simple formatter that prints nodes (without using source code).",				"I'm useful when AST are programmatically assembled. ",				"",				"I could be improved, but the goal is to get the information is a more or less ok form."			],			"category" : "AST-Core-Formatter"		},		"SHRBTextStyler" : {			"hash" : 3677952,			"definition" : "SHTextStyler subclass: #SHRBTextStyler\r\tuses: TRBProgramNodeVisitor\r\tinstanceVariableNames: 'charAttr parentheseLevel bracketLevel classOrMetaClass font isForWorkspace pixelHeight workspace'\r\tclassVariableNames: ''\r\tpackage: 'Shout-Styling'",			"comment" : [				"I'm the one who visits node to coloring the code"			],			"category" : "Shout-Styling"		},		"CoMockASTResultSetBuilder" : {			"hash" : 2866944,			"definition" : "CoASTResultSetBuilder subclass: #CoMockASTResultSetBuilder\r\tinstanceVariableNames: 'heuristic'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Tests-Core'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\theuristic:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "HeuristicCompletion-Tests-Core"		},		"CDFluidClassDefinitionParser" : {			"hash" : 4325120,			"definition" : "CDAbstractClassDefinitionParser subclass: #CDFluidClassDefinitionParser\r\tinstanceVariableNames: 'subclass'\r\tclassVariableNames: ''\r\tpackage: 'ClassParser-Parser'",			"comment" : [				"I'm parser for the new class syntax. ",				"",				"",				"### The new syntax for class definition (just for the class and not for the methods) is",				"",				"```",				"Superclass < #MyObject",				"\tuses: #MyTrait;",				"\tslots: { #a. #b };",				"\tsharedVariables: { #A. #B };",				"\ttags: {'tag2' . 'Core'} ;",				"\tlayout: VariableLayout; ",				"\tsharedPools: { #TextConstants } ;",				"\tpackage: #MyPackage",				"```",				"Pay attention all the messages should be keyword-based.",				"",				"The minimal class definition is the following one: ",				"",				"```",				"Superclass < #MyObject",				"\tpackage: #MyPackage",				"```",				"",				"For the implementors, we see that we should either handle a simple message composition or a cascade. ",				"",				"### Design Concerns ",				"Note that sending a message to the superclass is close to subclass: and it lets the class selects ",				"a class definition parser if the syntax should be extended. ",				"In addition having a binary message makes () unneccessary.",				""			],			"category" : "ClassParser-Parser"		},		"IRBuilder" : {			"hash" : 1254400,			"definition" : "Object subclass: #IRBuilder\r\tinstanceVariableNames: 'ir currentScope jumpBackTargetStacks jumpAheadStacks currentSequence sourceMapNodes sourceMapByteIndex'\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-IR-Manipulation'",			"comment" : [				"I provide a simple interface for constructing an IRMethod.  For example, to create an ir method that compares first instVar to first arg and returns 'yes' or 'no' (same example as in BytecodeGenerator), do:",				"",				"\tIRBuilder new",				"\t\tnumArgs: 1;",				"\t\taddTemps: #(a z);",				"\t\tpushReceiver;",				"\t\tpushInstVar: 1;",				"\t\tpushTemp: #a;",				"\t\tsend: #>;",				"\t\tjumpAheadTo: #else if: false;",				"\t\tpushLiteral: 'yes';",				"\t\treturnTop;",				"\t\tjumpAheadTarget: #else;",				"\t\tpushLiteral: 'no';",				"\t\treturnTop;",				"\t\tir",				"",				"Sending #compiledMethod to an ir method will generate its compiledMethod.  Sending #methodNode to it will decompile to its parse tree."			],			"category" : "OpalCompiler-Core-IR-Manipulation"		},		"SymbolicBytecode" : {			"hash" : 1063424,			"definition" : "Object subclass: #SymbolicBytecode\r\tinstanceVariableNames: 'description method offset bytes'\r\tclassVariableNames: ''\r\tpackage: 'Debugging-Core'",			"comment" : [				"I model a single bytecode. I know my value and my offset in the compiledMethod and know the compiledMethod I come from",				"",				"I am a relatively heavyweight object, I am created on demand for inspecting bytecodes.",				"",				"See #symbolicBytecode."			],			"category" : "Debugging-Core"		},		"ReifiedVar" : {			"hash" : 6596096,			"definition" : "Var subclass: #ReifiedVar\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "MicroKanren"		},		"Context" : {			"hash" : 9216,			"definition" : "InstructionStream variableSubclass: #Context\r\tinstanceVariableNames: 'stackp method closureOrNil receiver'\r\tclassVariableNames: 'PrimitiveFailToken QuickStep SpecialPrimitiveSimulators TryNamedPrimitiveTemplateMethod'\r\tpackage: 'Kernel-Methods'",			"comment" : [				"Instance variables:",				"\treceiver: <Object> (self)",				"\tclosureOrNil: <BlockClosure|nil> ",				"\t\tnil if I'm a method context",				"\t\tthe blockClosure being executed if I'm a block context",				"\tmethod <CompiledMethod> ",				"\t\tmethod being executed if I'm a method context",				"\t\tmethod holding the block if I'm a block context",				"\tvariable fields: <Object> temporary variables (including arguments)",				"",				"My instances hold all the dynamic state associated with the execution of either a method activation resulting from a message send or a block activation resulting from a block evaluation.",				"\t",				"MethodContexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.",				"",				"MethodContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a MethodContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal."			],			"category" : "Kernel-Methods"		},		"RBProgramNodeIdentityVisitor" : {			"hash" : 2842880,			"definition" : "RBProgramNodeVisitor subclass: #RBProgramNodeIdentityVisitor\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-RB'",			"comment" : [				"I am a node program visitor that reconstruct an exact copy of the visited RBNode object."			],			"category" : "MicroKanren-RB"		},		"CompiledCode" : {			"hash" : 807680,			"definition" : "ByteArray variableByteSubclass: #CompiledCode\r\tinstanceVariableNames: ''\r\tclassVariableNames: 'LargeFrame PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'\r\tpackage: 'Kernel-Methods'",			"comment" : [				"My instances (and subinstances) are objects suitable for execution by the virtual machine. My subclasses and I have a specific layout so the instances intermix both indexable pointer fields and indexable integer fields.",				"",				"\t",				"The current format of a CompiledCode is as follows:",				"",				"\theader (4 bytes)",				"\tliterals (4 bytes each)",				"\tbytecodes  (variable)",				"\ttrailer (variable)",				"",				"The header describes the compiled code. It's a small integer with the following format: ",				"",				"sign bit \t1 bit: \tif set, the method is encoded in the SecondaryBytecodeSet, else in the PrimaryBytecodeSet (See class variables) ",				"(index 0)\t15 bits:\tnumber of literals",				"(index 16)\t1 bit:\trequires counters (in the sista JIT, methods marked this way cannot trip)",				"(index 17)\t1 bit:\twhether a large frame size is needed",				"(index 18)\t6 bits:\tnumber of temporary variables",				"(index 24)\t4 bits:\tnumber of arguments to the method",				"(index 28)\t1 bit:\thas primitive",				"(index 29)\t1 bit:\tflag bit, ignored by the VM",				"",				"The trailer encodes how to fetch the method's sources. See CompiledMethodTrailer."			],			"category" : "Kernel-Methods"		},		"SkewBinaryCanonicalNumber" : {			"hash" : 6562816,			"definition" : "Object subclass: #SkewBinaryCanonicalNumber\r\tinstanceVariableNames: 'representation'\r\tclassVariableNames: ''\r\tpackage: 'Kernel-NumericalRepresentations'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\trepresentation:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Kernel-NumericalRepresentations"		},		"IRSequence" : {			"hash" : 1251584,			"definition" : "Object subclass: #IRSequence\r\tinstanceVariableNames: 'sequence orderNumber method'\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-IR-Nodes'",			"comment" : [				"A sequence is corresponds to a block in the control flow graph."			],			"category" : "OpalCompiler-Core-IR-Nodes"		},		"RBProgramNodeVisitor" : {			"hash" : 1173504,			"definition" : "Object subclass: #RBProgramNodeVisitor\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Visitors'",			"comment" : [				"RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.",				""			],			"category" : "AST-Core-Visitors"		},		"CDClassDefinitionParser" : {			"hash" : 4324608,			"definition" : "CDAbstractClassDefinitionParser subclass: #CDClassDefinitionParser\r\tinstanceVariableNames: 'subclass'\r\tclassVariableNames: ''\r\tpackage: 'ClassParser-Parser'",			"comment" : [				"I use the default node representation of classes to parse class definition and  return a dedicated class tree.",				"",				"The basic idea behing the implementation is to reuse as much as possible as the current parser infrastructure. This is why this class defines a visitMessageNode: method. ",				"",				"Main public API is ",				"\t- parse: aString"			],			"category" : "ClassParser-Parser"		},		"IconStyler" : {			"hash" : 2081536,			"definition" : "RBProgramNodeVisitor subclass: #IconStyler\r\tinstanceVariableNames: 'textModel stylerClasses'\r\tclassVariableNames: ''\r\tpackage: 'Reflectivity-Tools-Breakpoints'",			"comment" : [				"I'm in charge to styling an ast with highlighting. To highglight something I need the rubric text model in textModel."			],			"category" : "Reflectivity-Tools-Breakpoints"		},		"CoASTResultSetBuilder" : {			"hash" : 5310976,			"definition" : "CoResultSetBuilder subclass: #CoASTResultSetBuilder\r\tinstanceVariableNames: 'astNode node'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Model-SystemIntegration'",			"comment" : [				"I'm an abstract superclass for defining AST Based Complishons"			],			"category" : "HeuristicCompletion-Model-SystemIntegration"		},		"RGTraitCompositionVisitor" : {			"hash" : 4823552,			"definition" : "RBProgramNodeVisitor subclass: #RGTraitCompositionVisitor\r\tinstanceVariableNames: 'traitComposition'\r\tclassVariableNames: ''\r\tpackage: 'Ring-Core-Parsing'",			"comment" : [				"ast := (RBParser parseExpression: 'Trait1 + Trait2 + Trait3 + Trait4').",				"ast := (RBParser parseExpression: '(Trait2 - {#c})').",				"ast := (RBParser parseExpression: 'Trait1 + (Trait2 - {#c})').",				"ast := (RBParser parseExpression: 'Trait1 + (Trait2 - {#c}) + Trait3').",				"ast := (RBParser parseExpression: 'Trait1 + (Trait2 - #(c ahoj bla: bla:bla:)) + Trait3').",				"",				"composition := RGTraitComposition unnamed.",				"",				"visitor := RGTraitCompositionVisitor new.",				"visitor traitComposition: composition.",				"ast acceptVisitor: visitor.",				"",				"",				"",				""			],			"category" : "Ring-Core-Parsing"		},		"RFASTTranslator" : {			"hash" : 3057408,			"definition" : "OCASTTranslator subclass: #RFASTTranslator\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Reflectivity-Compiler'",			"comment" : [				"subclass of Opal that takes links into account"			],			"category" : "Reflectivity-Compiler"		},		"FBDOptimizedMessagesRewriter" : {			"hash" : 1668352,			"definition" : "RBProgramNodeVisitor subclass: #FBDOptimizedMessagesRewriter\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Flashback-Decompiler-Utilities'",			"comment" : [				"I am a tool that allows you to reoptimize messages into a decompiled method.",				"",				"I receive an AST and I replace non-optimized message nodes that have been reconstructed by the AST builder into optimized message nodes, then I return the AST.",				"",				"Public API : use rewriteAST: to transform it with optimized messages.",				"",				"example: FBDOptimizedMessagesRewriter rewriteAST: (Object >> #asString ) ast.",				"",				"I only rewrite nodes with \"reconstructed\" property to ensure that I reoptimize only the messages that were optimized in the non-decompiled method."			],			"category" : "Flashback-Decompiler-Utilities"		},		"CoTypeInferencer" : {			"hash" : 5316096,			"definition" : "Object subclass: #CoTypeInferencer\r\tinstanceVariableNames: 'returnType variables level arguments method temporaryVariables receiverClass argumentVariables'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Model-InitializeInferenceHeuristic'",			"comment" : [				"I am a simple type inferencer that is depth-bound.",				"That is, I infer a method up to a certain level of the callgraph."			],			"category" : "HeuristicCompletion-Model-InitializeInferenceHeuristic"		},		"OCASTTranslator" : {			"hash" : 1248768,			"definition" : "RBProgramNodeVisitor subclass: #OCASTTranslator\r\tinstanceVariableNames: 'methodBuilder effectTranslator valueTranslator'\r\tclassVariableNames: 'OptimizedMessages'\r\tpackage: 'OpalCompiler-Core-Translator'",			"comment" : [				"I visit an abstract syntax tree and generate IR (intermediate representation) instructions for each node by sending the appropriate message to my methodBuilder (an IRBuilder).  I hold onto my two subclasses ",				"OCASTTranslatorForValue for generating instructions for effect and value, and",				"OCASTTranslatorForEffect for generating instructions for effect only.",				"",				"Which one to use depends on the AST nodes and whether the code will only be executed (for effect only) or if the value is used afterwards (for value).",				"",				"For example, when translating a return, the value to return needs to be pushed on stack, so the valueTranslator is used:",				"visitReturnNode: aReturnNode ",				"\tvalueTranslator visitNode: aReturnNode value.",				"\tmethodBuilder returnTop.",				"\t",				"Whereas, in #visitMethodNode:,  the effectTranslator is used, because no value is pushed on stack at the end of the method body:",				"...effectTranslator visitNode: aMethodNode body.."			],			"category" : "OpalCompiler-Core-Translator"		},		"IRMethod" : {			"hash" : 1253376,			"definition" : "Object subclass: #IRMethod\r\tinstanceVariableNames: 'sourceNode startSequence numArgs properties tempMap pragmas additionalLiterals compiledMethod compilationContext irPrimitive'\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-IR-Nodes'",			"comment" : [				"I am a method in the IR (intermediate representation) language consisting of IRInstructions grouped by IRSequence (basic block).  The IRSequences form a control graph (therefore I only have to hold onto the starting sequence).  #compiledMethod will convert me to a CompiledMethod.  #methodNode will convert me back to a parse tree."			],			"category" : "OpalCompiler-Core-IR-Nodes"		},		"EFFormatter" : {			"hash" : 3145984,			"definition" : "RBProgramNodeVisitor subclass: #EFFormatter\r\tinstanceVariableNames: 'codeStream indent originalSource lineStart context isInCascadeNode lookAheadCode'\r\tclassVariableNames: 'DefaultPrettyPrintContext FormatAsYouReadPolicy'\r\tpackage: 'EnlumineurFormatter-Core'",			"comment" : [				"Enlumineur is a replacement of BlueInk pretty printer (now packaged in pharo-contributions/configurableFormatter).",				"",				"It was developed by Hugo Lasnier during 6 months internship within RMOD and supervised by S. Ducasse and G. Polito during 2019.",				"The code was revisited and cleaned but there are probably more glitches left. ",				"",				"Enlumineur enhancements compared to BlueInk are:",				"",				"- systematic test coverage with more than 270 tests",				"- full revisiting of settings with description and examples",				"- no way to break the code by entering a non space character to indent code",				"- support for {.....} long list",				"- cleaning coupled settings",				"- support for to:do: block like statement (multiline arguments)",				"- removal of \"traditional parentheses\" whatever it meant.",				"- new line and more indentations after the opening bracket",				"- A dedicated UI was in preparation but should be redone before introduced in Pharo.",				" See package Enlumineur-UI (https://github.com/Ducasse/enlumineur)",				"",				"Enlumineur should be improved to be able to reformat the full code of Pharo.",				"The tests are a first step to make sure that we understand what is impacted by a change.",				"",				"Implementation remarks",				"\t  - willBeMultiline: too costly because it formats the code to see if it fits.",				"\tWe should have other heuristics.",				"\t- formatBlock: should be improved and speed up. ",				"\tformatBlock2: is a first alternative but it broke some tests that should be evaluated. ",				"\t- Some Node extensions should be pushed to the packages their belong to. "			],			"category" : "EnlumineurFormatter-Core"		},		"CompiledMethod" : {			"hash" : 793344,			"definition" : "CompiledCode variableByteSubclass: #CompiledMethod\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Methods'",			"comment" : [				"Specific version of compiled code for method's.",				"",				"CompiledMethod instances can be in two forms:",				"- up until Pharo 6, they encode both the method and the inner closures bytecodes and literals.",				"- since Pharo 6, they encode only the method's bytecodes and literals.",				"",				"In addition the execution mechanics, a compiled method have two extra optional literals. The last literal, optional if there are no super sends, is the class in which the method is installed. The last but one literal is either the method's selector or an AdditionalMethodState instance. AdditionalMethodState instances are used to encode additional state to a method, as for example the pragmas.",				"",				"The bytecode encodes the trailer at the end, in most cases it has 4 bytes encoding the sourcer pointer (see CompiledMethodTrailer).",				"Thus endPC of a compiled method is not the size of the bytecode, but the size minus the length of the trailer."			],			"category" : "Kernel-Methods"		},		"RBProgramNodeReifyVisitor" : {			"hash" : 2853888,			"definition" : "RBProgramNodeVisitor subclass: #RBProgramNodeReifyVisitor\r\tinstanceVariableNames: 'state'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-RB'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tstate:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "MicroKanren-RB"		},		"Var" : {			"hash" : 6595584,			"definition" : "Object subclass: #Var\r\tinstanceVariableNames: 'id named'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tid:\t\t<Object>",				"\tnamed:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "MicroKanren"		},		"IRPushArray" : {			"hash" : 1257472,			"definition" : "IRInstruction subclass: #IRPushArray\r\tinstanceVariableNames: 'size cons'\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-IR-Nodes'",			"comment" : [				"I model the pushArray bytecode.",				"",				"Used for setting up the temp vectors and for the brace array construct: { }."			],			"category" : "OpalCompiler-Core-IR-Nodes"		},		"FullBlockClosure" : {			"hash" : 9728,			"definition" : "BlockClosure variableSubclass: #FullBlockClosure\r\tinstanceVariableNames: 'receiver'\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Methods'",			"comment" : [				"A FullBlockClosure is a closure that can be independent of any outerContext if desired.  It has its own method (currently reusing the startpc inst var) and its own receiver.  outerContext can be either a MethodContext/Context or nil.",				"",				"Instance Variables",				"\touterContext \t<Context>",				"\t(startpc) compiledBlock <CompiledBlock> for compatibility, this is startpc.",				"\tnumArgs \t\t<SmallInteger>",				"\treceiver:\t\t<Object>"			],			"category" : "Kernel-Methods"		},		"TRBProgramNodeVisitor" : {			"hash" : 1318656,			"definition" : "Trait named: #TRBProgramNodeVisitor\r\tpackage: 'AST-Core-Traits'",			"comment" : [				"A TRBProgramNodeVisitor is a simple Trait that define visitor methods. "			],			"category" : "AST-Core-Traits"		},		"RBParseTreeRewriter" : {			"hash" : 1196544,			"definition" : "RBParseTreeSearcher subclass: #RBParseTreeRewriter\r\tinstanceVariableNames: 'tree'\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Matching'",			"comment" : [				"ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then the answer is set to true, and the modified tree can be retrieved by the #tree method.",				"",				"",				"Here is a little script to rewrite a self halt into self dormantHalt. ",				"",				"\t| rewriter node |",				"\trewriter := RBParseTreeRewriter new.",				"\trewriter replace: 'self halt' with: 'self dormatHalt'.",				"\tnode := (ProtoObjectTest>>#testIfNil) parseTree.",				"\trewriter executeTree: node.",				"\t^ node formattedCode",				"",				"Note how do we get the transformed code. You can access the rewritten tree as follows:",				"rewriter tree.",				"",				"Now here is a full script showing how to compile the method back. ",				"",				"   | rewriter ok method |",				"\trewriter := RBParseTreeRewriter new.",				"\trewriter replaceMethod: self searchPattern with: self targetPattern.",				"\tmethod := (BIArrayExpressionTest>>#testNoExtraSpaceAroundPeriod).",				"\tok := rewriter executeTree: method parseTree.",				"\tok ifFalse: [ ^ 'did not work' ].",				"\tAuthor ",				"\t\tuseAuthor: 'Refactoring'",				"\t\tduring: [  ",				"\t\t\tmethod origin ",				"\t\t\t\tcompile: rewriter tree formattedCode ",				"\t\t\t\tclassified: method protocol ]",				"",				"",				"Have a look at the users of deprecated:",				"",				"\t\tdeprecated: 'Please use #isPinnedInMemory instead'",				"\t\ttransformWith: '`@receiver isPinned' -> '`@receiver isPinnedInMemory'.",				"",				"You can also have a look at the ParseTreeRewriterTest class.",				"",				"",				"Instance Variables:",				"\ttree\t<RBProgramNode>\tthe parse tree we're transforming",				"\t\t\t",				"\t"			],			"category" : "AST-Core-Matching"		},		"PharoDocCommentNode" : {			"hash" : 4046080,			"definition" : "Object subclass: #PharoDocCommentNode\r\tinstanceVariableNames: 'sourceNode expression result'\r\tclassVariableNames: 'DocCommentEnabled'\r\tpackage: 'PharoDocComment-Base'",			"comment" : [				"I represent a example expression (expression and value) within a method",				"comment (RBCommentNode). Every pair of Pharo expression and a separator (default \">>>\") can be styled as Pharo code and the editor iconstyler  can highlight the code and evaluate the expression.",				"",				"Example, within a method comment:",				"",				"\" 3 + 4 >>> 7\"",				"",				"The example code should show an  expression 3 + 4 and the expected value 7.",				"",				"See setting on \"Code Browsing\" to enable / disable this doc comment style."			],			"category" : "PharoDocComment-Base"		},		"CoASTHeuristicsResultSetBuilder" : {			"hash" : 5311488,			"definition" : "CoASTResultSetBuilder subclass: #CoASTHeuristicsResultSetBuilder\r\tinstanceVariableNames: 'messageHeuristic methodNodeHeuristic variablesHeuristic'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Model-SystemIntegration'",			"comment" : [				"I am the an AST based heuristics builder.",				"",				"When building the complishon, I build the AST from the source in the context, and get the current node from the context position.",				"Then I do a double dispatch on the current node and from it",				"1) I decide what fetchers to create",				"2) I extract the currently typed text and set is as initial filter"			],			"category" : "HeuristicCompletion-Model-SystemIntegration"		},		"RBProgramNodeSubstitutionVisitor" : {			"hash" : 2843392,			"definition" : "RBProgramNodeIdentityVisitor subclass: #RBProgramNodeSubstitutionVisitor\r\tinstanceVariableNames: 'substitution'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-RB'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tsubstitution:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "MicroKanren-RB"		},		"RBProgramNodeWalkVisitor" : {			"hash" : 2854400,			"definition" : "RBProgramNodeVisitor subclass: #RBProgramNodeWalkVisitor\r\tinstanceVariableNames: 'walker'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-RB'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\twalker:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "MicroKanren-RB"		},		"CDTraitCompositionBuilder" : {			"hash" : 4336384,			"definition" : "Object subclass: #CDTraitCompositionBuilder\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'ClassParser-Model'",			"comment" : [				"I am in charge of building a Trait composition. ",				"",				"aTraitCompositionNode is composed of TraitNode."			],			"category" : "ClassParser-Model"		},		"TypingVisitor" : {			"hash" : 3202304,			"definition" : "RBProgramNodeVisitor subclass: #TypingVisitor\r\tinstanceVariableNames: 'typeStack'\r\tclassVariableNames: ''\r\tpackage: 'NECompletion-Model'",			"comment" : [				"A visitor that does the typing for better completion. No type guessing, just using the information that's already known to the system"			],			"category" : "NECompletion-Model"		},		"BlockClosure" : {			"hash" : 9472,			"definition" : "Object variableSubclass: #BlockClosure\r\tinstanceVariableNames: 'outerContext startpc numArgs'\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Methods'",			"comment" : [				"I contain a sequence of operations. I am defined by Smalltalk expressions inside square brackets. I permit to defer the enclosed operations until I execute a variant of #value. I can have my own arguments and temporaries as a regular method, but I am also able to use external variables: my enclosing method or block temporaries, arguments and receiver.",				"",				"examples :",				"[ 1 + 2 ] value",				"[ :arg | ",				"\t| temp | ",				"\ttemp := arg. ",				"\ttemp ] value: 5",				"[ ^ 5 ] value",				"",				"My return value corresponds to my final expression. A non local return (^) has the same effect as if I did not exist: it returns from my enclosing method, even if I'm nested in other blocks. ",				"",				"Implementation:",				"",				"Instance variables:",				"\touterContext <Context|nil> context that defined me",				"\tstartpc: <SmallInteger> (pc = program counter) offset of my first bytecode instruction in the compiledMethod bytecode  ",				"\tnumArgs: <SmallInteger> my number of arguments",				"",				"I am created at runtime through a special bytecode:",				"closureNumCopied: x numArgs: y bytes z1 to z2",				"On creation, the currently executed context is set to my outerContext, z1 is set as my startpc and y is set as my numArgs. After my creation, the current execution flow jumps to my last bytecode, z2, to skip the execution of my bytecode which is deferred until I execute a variant of #value.",				"",				"I am executed when I receive a variant of the message value. This message creates a new context, a block context <MethodContext>, which reference me in its variable closureOrNil. This new context executes my bytecode, which correspond to a subset of the bytecode of my enclosing method, starting at startpc and ending in blockReturn/return bytecode.",				"",				"Accessing variables of the my enclosing context is different depending on variables because of various optimizations:",				"- self: I access the receiver of my enclosing method by accessing my context's receiver, which is always set to the enclosing method receiver.",				"- copied variables: If I read a variable from an outerContext but I don't write into it and the variable is not modified after the BlockClosure creation, then the variable is copied in the blockClosure to be more efficient. ",				"- full variable: If I access and edit a variable from an outerContext, then the variable is stored in an external heap allocated array (named tempVector). The tempVector is known by the method and the block so they can both read and write these variables.",				"",				"Optimized block closures: ",				"Common blocks (2/3 of the blocks) are optimized directly in the compiler and have special behaviors. These blocks are the arguments/receiver of control structures: #ifNil:, #ifNotNil:, #ifTrue:, #ifFalse:, #whileTrue:, #whileFalse:, #to:do:, #to:by:do: ."			],			"category" : "Kernel-Methods"		},		"RBNode" : {			"hash" : 1177600,			"definition" : "Object subclass: #RBNode\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Nodes'",			"comment" : [				"I'm the superclass of the all the nodes for ",				"\t- expressions and methods (subclasses of RBProgramNode) - historically it was the only tree and ",				"\tit was the only part concerned with refactorings (hence the RB suffix for RegactoringBrowser).",				"\t- class definition (just nodes to represent the class creation messages),",				"\t- full program (class definitions or method definitions)",				"",				"In the future my prefix may change to convey the fact that my hierarchy is much more than supporting compiler and refactorings.",				"",				"I'm a new player in the field, do not hesitate to improve me."			],			"category" : "AST-Core-Nodes"		},		"RBProgramNodeSendsoVisitor" : {			"hash" : 2850304,			"definition" : "RBProgramNodeVisitor subclass: #RBProgramNodeSendsoVisitor\r\tinstanceVariableNames: 'goals selectorVar'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-RB'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tgoals:\t\t<Object>",				"\tselectorVar:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "MicroKanren-RB"		},		"RBReadBeforeWrittenTester" : {			"hash" : 1182976,			"definition" : "RBProgramNodeVisitor subclass: #RBReadBeforeWrittenTester\r\tinstanceVariableNames: 'read checkNewTemps scopeStack'\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Visitors'",			"comment" : [				"RBReadBeforeWrittenTester is a visitor that identifies variables that may have been read before they are initialized.",				"",				"Instance Variables:",				"\tcheckNewTemps\t<Boolean>\tdescription of checkNewTemps",				"\tread\t<Collection>\tdescription of read",				"\tscopeStack\t<OrderedCollection>\tdescription of scopeStack",				""			],			"category" : "AST-Core-Visitors"		},		"CompiledBlock" : {			"hash" : 912896,			"definition" : "CompiledCode variableByteSubclass: #CompiledBlock\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Methods'",			"comment" : [				"Specific version of compiled code for block's.",				"",				"CompiledBlock are used only in the recent BlockClosure implementation by Eliot Miranda and Clement Bera, also known as FullBlockClosure. This new representation makes possible heavier runtime optimisations while simplifying a lot of code, both image-side and VM-side.",				"",				"In addition the execution mechanics, a compiled block have an extra optional literal. The last literal is the compiled code referring to the compiled block. ",				"",				""			],			"category" : "Kernel-Methods"		},		"RBDumpVisitor" : {			"hash" : 1184768,			"definition" : "RBProgramNodeVisitor subclass: #RBDumpVisitor\r\tinstanceVariableNames: 'stream'\r\tclassVariableNames: ''\r\tpackage: 'AST-Core-Visitors'",			"comment" : [				"I'm a visitor that generates code whose execution will recreate the visited node (similarly to storeOn: protocol).",				"This is handy because we can simply serialize the object in a textual form without requiring a separate parser.",				"",				"I'm used by reflexivity.",				"",				"try me! ",				"(RBDumpVisitor >> #stream) ast dump",				"",				"Instance Variables",				"\tstream:\t\t<Object>\t\tThe stream holding the output. Filled up throughout the visit.",				""			],			"category" : "AST-Core-Visitors"		}	},	"messages" : {		"sourceNode" : {			"implementors" : {				"IRSequence" : {					"sourceCode" : [						"sourceNode",						"",						"\t\"we should do better here\"",						"",						"\t^ RBSequenceNode new"					],					"body" : [						"^ RBSequenceNode new"					],					"isTestMethod" : false,					"category" : "inspector",					"comment" : [						"we should do better here"					],					"hash" : 2045231,					"argumentNames" : [ ]				},				"PharoDocCommentNode" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ sourceNode"					],					"body" : [						"^ sourceNode"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 4905365,					"argumentNames" : [ ]				},				"Context" : {					"sourceCode" : [						"sourceNode",						"",						"\t\"Return the source node that created the method or the block of this context\"",						"",						"\t^ closureOrNil",						"\t\t  ifNil: [ self compiledCode sourceNode ]",						"\t\t  ifNotNil: [ closureOrNil sourceNode ]"					],					"body" : [						"^ closureOrNil",						"\t  ifNil: [ self compiledCode sourceNode ]",						"\t  ifNotNil: [ closureOrNil sourceNode ]"					],					"isTestMethod" : false,					"category" : "*OpalCompiler-Core",					"comment" : [						"Return the source node that created the method or the block of this context"					],					"hash" : 804259,					"argumentNames" : [ ]				},				"TextMethodLink" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ sourceNode"					],					"body" : [						"^ sourceNode"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2764189,					"argumentNames" : [ ]				},				"FullBlockClosure" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ self compiledBlock sourceNodeInOuter"					],					"body" : [						"^ self compiledBlock sourceNodeInOuter"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 803586,					"argumentNames" : [ ]				},				"CompiledMethod" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ self ast"					],					"body" : [						"^ self ast"					],					"isTestMethod" : false,					"category" : "*opalcompiler-core",					"comment" : [ ],					"hash" : 1587055,					"argumentNames" : [ ]				},				"CompiledCode" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ self subclassResponsibility"					],					"body" : [						"^ self subclassResponsibility"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 1601391,					"argumentNames" : [ ]				},				"IRBuilder" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ sourceMapNodes ifEmpty: [ nil ] ifNotEmpty: [ sourceMapNodes last ]"					],					"body" : [						"^ sourceMapNodes ifEmpty: [ nil ] ifNotEmpty: [ sourceMapNodes last ]"					],					"isTestMethod" : false,					"category" : "mapping",					"comment" : [ ],					"hash" : 2048613,					"argumentNames" : [ ]				},				"SycSourceCodeCommand" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ sourceNode"					],					"body" : [						"^ sourceNode"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 3167383,					"argumentNames" : [ ]				},				"CompiledBlock" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ self sourceNodeInOuter"					],					"body" : [						"^ self sourceNodeInOuter"					],					"isTestMethod" : false,					"category" : "*OpalCompiler-Core",					"comment" : [ ],					"hash" : 1706607,					"argumentNames" : [ ]				},				"IRMethod" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ sourceNode"					],					"body" : [						"^ sourceNode"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2112661,					"argumentNames" : [ ]				},				"BlockClosure" : {					"sourceCode" : [						"sourceNode",						"",						"\t\"Return an instance of RBBlockNode representing the receiver's AST.\"",						"",						"\t\"the bytecode just before the first bytecode of the block is a bytecode that creates the complete block\"",						"",						"\t^ self method sourceNodeForPC: self startpc - 1"					],					"body" : [						"^ self method sourceNodeForPC: self startpc - 1"					],					"isTestMethod" : false,					"category" : "*OpalCompiler-Core",					"comment" : [						"Return an instance of RBBlockNode representing the receiver's AST."					],					"hash" : 803751,					"argumentNames" : [ ]				},				"IRInstruction" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ sourceNode"					],					"body" : [						"^ sourceNode"					],					"isTestMethod" : false,					"category" : "mapping",					"comment" : [ ],					"hash" : 2108309,					"argumentNames" : [ ]				},				"SymbolicBytecode" : {					"sourceCode" : [						"sourceNode",						"",						"\t^ self method sourceNode sourceNodeForPC: self offset"					],					"body" : [						"^ self method sourceNode sourceNodeForPC: self offset"					],					"isTestMethod" : false,					"category" : "mapping",					"comment" : [ ],					"hash" : 1857672,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#sendso",				"BlockClosure>>#argumentNames",				"BlockClosure>>#temporaryVariables",				"BlockClosure>>#temporaryVariableNamed:",				"BlockClosure>>#gtInspectorSourceCodeIn:",				"BlockClosure>>#printOn:",				"BlockClosure>>#gtSpotterCodePreviewIn:",				"BlockClosure>>#unaryRBNode",				"BlockClosure>>#context",				"BlockClosure>>#tempNames",				"BlockClosureTest>>#testSourceNodeOptimized",				"CleanBlockClosure>>#printOn:",				"CompiledBlock>>#printOn:",				"CompiledMethod>>#sourceNodeForPC:",				"CompiledMethod>>#temporaryVariables",				"CompiledMethod>>#sendso",				"CompiledMethod>>#temporaryVariableNamed:",				"Context>>#temporaryVariables",				"Context>>#sourceNode",				"DoItVariableTest>>#testReadCompilation",				"DoItVariableTest>>#testWriteCompilation",				"FreshRB>>#onState:withVars:",				"GTIRBrowser>>#sourceIn:",				"IRBuilder>>#createTempVectorNamed:withVars:",				"IRBuilder>>#cacheIndex:",				"IRBuilder>>#numArgs:",				"IRBuilder>>#add:",				"IRFix>>#convertRet:forSeq:",				"IRFix>>#convertStorePop:forSeq:",				"IRInstruction>>#gtInspectorSourceCodeIn:",				"IRInstruction>>#gtInspectorTreeIn:",				"IRInstruction>>#sourceInterval",				"IRMethod>>#sourceInterval",				"IRMethod>>#generate:",				"IRMethod>>#gtInspectorSourceCodeIn:",				"IRSequence>>#gtInspectorSourceCodeIn:",				"IRSequence>>#gtInspectorTreeIn:",				"MetaSTExporter>>#encodeCompiledMethod:ofSelector:",				"MethodMapTest>>#testDeadContextSourceNode",				"MethodMapTest>>#testBlockWithEnclosedBlockSourceNode",				"MethodMapTest>>#testBlockAndContextSourceNode",				"MethodMapTest>>#testBlockSourceNode",				"MethodMapTest>>#inlinedBlockSourceNode",				"MethodMapTest>>#testThisContextSourceNode",				"MethodMapTest>>#testBlockWithTempsSourceNode",				"MethodMapTest>>#testBlockWithArgAndEnclosedBlockSourceNode",				"OCASTCheckerTest>>#testSemanticAnalysisOnNonMethodNode",				"OCASTTranslatorMappingForFullBlockClosuresTest>>#assertBlockNodeHasCorrectIR:",				"OCBytecodeToASTCache>>#generateForNode:",				"OCCleanBlockTest>>#testBlockIsClean",				"OCCleanBlockTest>>#testBlockIsNotClean",				"OCClosureTest>>#testBlockTemps",				"PharoDocCommentExpression>>#methodClass",				"ProtoObject>>#mustBeBooleanCompileExpression:andCache:",				"RBBlockNode>>#irInstruction",				"RBFindAndReplaceMethodRefactoring>>#findOcurrencesIn:of:",				"RBFindAndReplaceMethodRefactoring>>#matchNodes",				"RBNodeTheoryTest>>#testUnifyEmptyBlock",				"RBNodeTheoryTest>>#testUnifyLiteralBlock",				"RBProgramNode>>#irInstruction",				"SindarinBytecodeToASTCache>>#generateForCompiledMethod:",				"StDebugger>>#initializeStack",				"StDebuggerContext>>#argumentsNodes",				"StepToNextDoIterationDbgScript>>#context:isForBlock:",				"SymbolicBytecode>>#sourceNode",				"SymbolicBytecode>>#gtInspectorTreeIn:",				"SymbolicBytecode>>#sourceInterval"			]		},		"consedObject:" : {			"implementors" : {				"Object" : {					"sourceCode" : [						"consedObject: car",						"",						"\t^ Cons car: car cdr: self"					],					"body" : [						"^ Cons car: car cdr: self"					],					"isTestMethod" : false,					"category" : "*Collections-Sequenceable-Cons",					"comment" : [ ],					"hash" : 18637811,					"argumentNames" : [						"car"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"Object>>#cons:"			]		},		"testSenderoForEmptyBlockClosure" : {			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"testSenderoForEmptyBlockClosure",						"",						"\tself",						"\t\tassert: [ :selector | [  ] sendso value: selector ] asGoal solutions",						"\t\tequals: #(  )",						"\t\tmodulo: #asOrderedCollection"					],					"body" : [						"self",						"\tassert: [ :selector | [  ] sendso value: selector ] asGoal solutions",						"\tequals: #(  )",						"\tmodulo: #asOrderedCollection"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4175737,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			]		},		"asGoalWithUnaryASTof:contextVariables:" : {			"implementors" : {				"BlockClosure" : {					"sourceCode" : [						"asGoalWithUnaryASTof: aBlock contextVariables: aCollection",						"",						"\t^ self",						"\t\t  asGoalWithASTof: aBlock",						"\t\t  contextVariables: aCollection",						"\t\t  select: [ :aSequenceNode | ",						"\t\t\t  aSequenceNode statements in: [ :statements | ",						"\t\t\t\t  statements size = 1",						"\t\t\t\t\t  ifTrue: [ statements first ]",						"\t\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t\t  Error signal:",						"\t\t\t\t\t\t\t  ('Assumption that {} has 1 statement only is violated.' ",						"\t\t\t\t\t\t\t\t   format: { aSequenceNode }) ] ] ]"					],					"body" : [						"^ self",						"\t  asGoalWithASTof: aBlock",						"\t  contextVariables: aCollection",						"\t  select: [ :aSequenceNode | ",						"\t\t  aSequenceNode statements in: [ :statements | ",						"\t\t\t  statements size = 1",						"\t\t\t\t  ifTrue: [ statements first ]",						"\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t  Error signal:",						"\t\t\t\t\t\t  ('Assumption that {} has 1 statement only is violated.' ",						"\t\t\t\t\t\t\t   format: { aSequenceNode }) ] ] ]"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 34882421,					"argumentNames" : [						"aBlock",						"aCollection"					]				}			},			"senders" : [				"ACL>>#focus:do:",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#'<~~>'",				"BlockClosure>>#'<~>'",				"BlockClosure>>#'<~~~>'",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_05_rewriting_unbound",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_15",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_32",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_55",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_21",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_05",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byBlockClosure",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_44",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_backward",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_49",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46_variablesBindingManually",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_07",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_28",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_19",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46_variablesBindingByEqualSameº"			]		},		"asRBNode" : {			"implementors" : {				"ReifiedVar" : {					"sourceCode" : [						"asRBNode",						"",						"\t^ RBLogicVariableNode named: self symbol logicVar: self"					],					"body" : [						"^ RBLogicVariableNode named: self symbol logicVar: self"					],					"isTestMethod" : false,					"category" : "converting",					"comment" : [ ],					"hash" : 7390099,					"argumentNames" : [ ]				},				"RBNode" : {					"sourceCode" : [						"asRBNode",						"",						"\t^ self"					],					"body" : [						"^ self"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 2036872,					"argumentNames" : [ ]				},				"Var" : {					"sourceCode" : [						"asRBNode",						"",						"\t^ RBLogicVariableNode named: named logicVar: self"					],					"body" : [						"^ RBLogicVariableNode named: named logicVar: self"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 7389364,					"argumentNames" : [ ]				}			},			"senders" : [				"ACL>>#valueWithArguments:",				"ACL>>#rewriting:rewritten:focusAST:focusVar:do:",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"FreshRB>>#onState:withVars:",				"RBLogicVariableNode>>#walkSBRAL:forState:",				"RBNodePredicatesTest>>#arguments_testSenderoBackwards",				"RBNodeTheoryTest>>#testUnifyConsIsAtomBlock",				"RBProgramNodeSendsoVisitor>>#visitLogicVariableNode:",				"RBProgramNodeWalkVisitor>>#visitLogicVariableNode:",				"TheLittleProver>>#cdrOfConsº",				"TheLittleProver>>#memberº",				"TheLittleProver>>#equalIfº",				"TheLittleProverTest>>#expectedRBNode_chapter_02_frame_7",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_05_rewriting_unbound",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_15",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_32",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_55",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_21",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_05",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byBlockClosure",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_44",				"TheLittleProverTest>>#expectedRBNode_chapter_02_frame_12",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_backward",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_49",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46_variablesBindingManually",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_07",				"TheLittleProverTest>>#expectedRBNode_chapter_01_frame_55",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_28",				"TheLittleProverTest>>#expectedRBNode_chapter_01_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_19",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46_variablesBindingByEqualSameº"			]		},		"visitTemporaryNode:" : {			"implementors" : {				"RBProgramNodeIdentityVisitor" : {					"sourceCode" : [						"visitTemporaryNode: aNode",						"",						"\tself shouldBeImplemented"					],					"body" : [						"self shouldBeImplemented"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20676164,					"argumentNames" : [						"aNode"					]				},				"SHRBTextStyler" : {					"sourceCode" : [						"visitTemporaryNode: aTemporaryNode",						"",						"\t| methodOrBlockTempStyle |",						"\tmethodOrBlockTempStyle := self methodOrBlockTempStyleFor:",						"\t\t                          aTemporaryNode.",						"\tself addStyle: methodOrBlockTempStyle forNode: aTemporaryNode"					],					"body" : [						"| methodOrBlockTempStyle |",						"methodOrBlockTempStyle := self methodOrBlockTempStyleFor:",						"\t                          aTemporaryNode.",						"self addStyle: methodOrBlockTempStyle forNode: aTemporaryNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 21774058,					"argumentNames" : [						"aTemporaryNode"					]				},				"TypingVisitor" : {					"sourceCode" : [						"visitTemporaryNode: aTemporaryNode",						"",						"\t(typeStack top includesKey: aTemporaryNode name) ifFalse: [ ^ self ].",						"\taTemporaryNode",						"\t\tpropertyAt: #type",						"\t\tput: (typeStack top at: aTemporaryNode name)"					],					"body" : [						"(typeStack top includesKey: aTemporaryNode name) ifFalse: [ ^ self ].",						"aTemporaryNode",						"\tpropertyAt: #type",						"\tput: (typeStack top at: aTemporaryNode name)"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 21036917,					"argumentNames" : [						"aTemporaryNode"					]				},				"CoTypeInferencer" : {					"sourceCode" : [						"visitTemporaryNode: aRBTemporaryNode",						"",						"\t^ self ensureTypeOfTemporaryVariable: aRBTemporaryNode name"					],					"body" : [						"^ self ensureTypeOfTemporaryVariable: aRBTemporaryNode name"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23149395,					"argumentNames" : [						"aRBTemporaryNode"					]				},				"RBProgramNodeSubstitutionVisitor" : {					"sourceCode" : [						"visitTemporaryNode: aNode",						"",						"\t^ aNode isVariable",						"\t\t  ifTrue: [ ",						"\t\t\t  (substitution at: aNode name) copy",						"\t\t\t\t  parent: aNode parent;",						"\t\t\t\t  yourself \"Here assume to talk with RBLogicVariable objs.\" ]",						"\t\t  ifFalse: [ aNode ]"					],					"body" : [						"^ aNode isVariable",						"\t  ifTrue: [ ",						"\t\t  (substitution at: aNode name) copy",						"\t\t\t  parent: aNode parent;",						"\t\t\t  yourself \"Here assume to talk with RBLogicVariable objs.\" ]",						"\t  ifFalse: [ aNode ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20678269,					"argumentNames" : [						"aNode"					]				},				"TRBProgramNodeVisitor" : {					"sourceCode" : [						"visitTemporaryNode: aNode",						"",						"\t\"Sent *each time* a temporary node is found\"",						"",						"\t^ self visitVariableNode: aNode"					],					"body" : [						"^ self visitVariableNode: aNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [						"Sent *each time* a temporary node is found"					],					"hash" : 19151808,					"argumentNames" : [						"aNode"					]				},				"IconStyler" : {					"sourceCode" : [						"visitTemporaryNode: aNode",						"",						"\tself addIconStyle: aNode.",						"\tsuper visitTemporaryNode: aNode"					],					"body" : [						"self addIconStyle: aNode.",						"super visitTemporaryNode: aNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19915523,					"argumentNames" : [						"aNode"					]				},				"CoASTResultSetBuilder" : {					"sourceCode" : [						"visitTemporaryNode: aRBReturnNode",						"",						"\t^ self visitNode: aRBReturnNode"					],					"body" : [						"^ self visitNode: aRBReturnNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23144128,					"argumentNames" : [						"aRBReturnNode"					]				},				"RBProgramNodeVisitor" : {					"sourceCode" : [						"visitTemporaryNode: aNode",						"",						"\t\"Sent *each time* a temporary node is found\"",						"",						"\t^ self visitVariableNode: aNode"					],					"body" : [						"^ self visitVariableNode: aNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [						"Sent *each time* a temporary node is found"					],					"hash" : 19006656,					"argumentNames" : [						"aNode"					]				}			},			"senders" : [				"ArgumentVariable>>#acceptVisitor:node:",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"IconStyler>>#visitTemporaryNode:",				"PrimitiveErrorVariable>>#acceptVisitor:node:",				"RBTemporaryNode>>#acceptVisitor:",				"TemporaryVariable>>#acceptVisitor:node:"			]		},		"visitLogicVariableNode:" : {			"implementors" : {				"RBProgramNodeIdentityVisitor" : {					"sourceCode" : [						"visitLogicVariableNode: aRBMKVarNode",						"",						"\tself shouldNotImplement"					],					"body" : [						"self shouldNotImplement"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20676164,					"argumentNames" : [						"aRBMKVarNode"					]				},				"RBProgramNodeSubstitutionVisitor" : {					"sourceCode" : [						"visitLogicVariableNode: aNode",						"",						"\t^ (substitution at: aNode) copy in: [ :aVar | ",						"\t\t  aVar parent ifNil: [ aVar parent: aNode parent ].",						"\t\t  aVar ]"					],					"body" : [						"^ (substitution at: aNode) copy in: [ :aVar | ",						"\t  aVar parent ifNil: [ aVar parent: aNode parent ].",						"\t  aVar ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20677065,					"argumentNames" : [						"aNode"					]				},				"RBProgramNodeReifyVisitor" : {					"sourceCode" : [						"visitLogicVariableNode: aNode",						"",						"\tstate := state reifier value: aNode logicVar"					],					"body" : [						"state := state reifier value: aNode logicVar"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20687415,					"argumentNames" : [						"aNode"					]				},				"RBDumpVisitor" : {					"sourceCode" : [						"visitLogicVariableNode: aRBMKVarNode",						"",						"\tself visitVariableNode: aRBMKVarNode.",						"\tstream nextPutAll: aRBMKVarNode logicVar asString"					],					"body" : [						"self visitVariableNode: aRBMKVarNode.",						"stream nextPutAll: aRBMKVarNode logicVar asString"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 19018876,					"argumentNames" : [						"aRBMKVarNode"					]				},				"RBProgramNodeSendsoVisitor" : {					"sourceCode" : [						"visitLogicVariableNode: aNode",						"",						"\tsuper visitLogicVariableNode: aNode.",						"",						"\tSymbol selectorTable",						"\t\tselect: [ :each | each isUnary ]",						"\t\tthenDo: [ :each | ",						"\t\t\tgoals add: [ :receiver | ",						"\t\t\t\tselectorVar unifyo value:",						"\t\t\t\t\t(RBMessageNode receiver: receiver asRBNode selector: each) ]",						"\t\t\t\t\tasGoal ]"					],					"body" : [						"super visitLogicVariableNode: aNode.",						"",						"Symbol selectorTable",						"\tselect: [ :each | each isUnary ]",						"\tthenDo: [ :each | ",						"\t\tgoals add: [ :receiver | ",						"\t\t\tselectorVar unifyo value:",						"\t\t\t\t(RBMessageNode receiver: receiver asRBNode selector: each) ]",						"\t\t\t\tasGoal ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20684890,					"argumentNames" : [						"aNode"					]				},				"RBProgramNodeWalkVisitor" : {					"sourceCode" : [						"visitLogicVariableNode: aNode",						"",						"\t^ (walker value: aNode logicVar) asRBNode"					],					"body" : [						"^ (walker value: aNode logicVar) asRBNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20687730,					"argumentNames" : [						"aNode"					]				},				"EFFormatter" : {					"sourceCode" : [						"visitLogicVariableNode: aNode",						"",						"\tself writeString: aNode logicVar asString"					],					"body" : [						"self writeString: aNode logicVar asString"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 20979644,					"argumentNames" : [						"aNode"					]				},				"RBProgramNodeVisitor" : {					"sourceCode" : [						"visitLogicVariableNode: aRBMKVarNode",						"",						"\tself visitVariableNode: aRBMKVarNode"					],					"body" : [						"self visitVariableNode: aRBMKVarNode"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 19006869,					"argumentNames" : [						"aRBMKVarNode"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"RBLogicVariableNode>>#acceptVisitor:",				"RBProgramNodeSendsoVisitor>>#visitLogicVariableNode:"			]		},		"testSenderoBackwards" : {			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"testSenderoBackwards",						"",						"\tself arguments_testSenderoBackwards bind: [ :receiverNode :messageNodes | ",						"\t\tself",						"\t\t\tassert: ([ :aSend | ",						"\t\t\t\t [ :o :ast | ast sendso value: aSend ] asGoalWithASTof: [ :o | o ] ]",						"\t\t\t\t\t asGoal solutions next: messageNodes size)",						"\t\t\tequals: messageNodes",						"\t\t\tmodulo: #asOrderedCollection ]"					],					"body" : [						"self arguments_testSenderoBackwards bind: [ :receiverNode :messageNodes | ",						"\tself",						"\t\tassert: ([ :aSend | ",						"\t\t\t [ :o :ast | ast sendso value: aSend ] asGoalWithASTof: [ :o | o ] ]",						"\t\t\t\t asGoal solutions next: messageNodes size)",						"\t\tequals: messageNodes",						"\t\tmodulo: #asOrderedCollection ]"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4175350,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			]		},		"testSenderoForIdentityBlockClosure" : {			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"testSenderoForIdentityBlockClosure",						"",						"\tself",						"\t\tassert:",						"\t\t[ :selector | [ :o | o ] sendso value: selector ] asGoal solutions",						"\t\tequals: #(  )",						"\t\tmodulo: #asOrderedCollection"					],					"body" : [						"self",						"\tassert:",						"\t[ :selector | [ :o | o ] sendso value: selector ] asGoal solutions",						"\tequals: #(  )",						"\tmodulo: #asOrderedCollection"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4175737,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			]		},		"asGoalWithASTof:contextVariables:select:" : {			"implementors" : {				"BlockClosure" : {					"sourceCode" : [						"asGoalWithASTof: aBlock contextVariables: aCollection select: selectBlock",						"",						"\t^ FreshRB new",						"\t\t  receiver: aBlock;",						"\t\t  nodeBlock: self;",						"\t\t  selectBlock: selectBlock;",						"\t\t  contextVariables: aCollection;",						"\t\t  yourself"					],					"body" : [						"^ FreshRB new",						"\t  receiver: aBlock;",						"\t  nodeBlock: self;",						"\t  selectBlock: selectBlock;",						"\t  contextVariables: aCollection;",						"\t  yourself"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 51923487,					"argumentNames" : [						"aBlock",						"aCollection",						"selectBlock"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#asGoalWithUnaryASTof:contextVariables:",				"BlockClosure>>#asGoalWithASTof:select:"			]		},		"<~>" : {			"implementors" : {				"BlockClosure" : {					"sourceCode" : [						"<~> aBlock",						"",						"\t^ [ :a :b | ",						"\t  [ :ast | ",						"\t  [ :x | ",						"\t  | z |",						"\t  z := aBlock substituteVariablesUsingSequenceableCollection:",						"\t\t       (Array with: x).",						"\t  (ast unifyo value: a) , (z unifyo value: b) ] ]",						"\t\t  asGoalWithUnaryASTof: self",						"\t\t  contextVariables: #(  ) ]"					],					"body" : [						"^ [ :a :b | ",						"  [ :ast | ",						"  [ :x | ",						"  | z |",						"  z := aBlock substituteVariablesUsingSequenceableCollection:",						"\t       (Array with: x).",						"  (ast unifyo value: a) , (z unifyo value: b) ] ]",						"\t  asGoalWithUnaryASTof: self",						"\t  contextVariables: #(  ) ]"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 17842655,					"argumentNames" : [						"aBlock"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"TheLittleProver>>#equalSameº",				"TheLittleProver>>#isAtomNilº",				"TheLittleProverTest>>#flapjackNilFalseº"			]		},		"unaryRBNode" : {			"implementors" : {				"BlockClosure" : {					"sourceCode" : [						"unaryRBNode",						"",						"\t^ self sourceNode body statements in: [ :statements | ",						"\t\t  statements size = 1",						"\t\t\t  ifTrue: [ statements first ]",						"\t\t\t  ifFalse: [ ",						"\t\t\t\t  Error signal:",						"\t\t\t\t\t  ('Assumption that {} has 1 statement only is violated.' ",						"\t\t\t\t\t\t   format: { self }) ] ]"					],					"body" : [						"^ self sourceNode body statements in: [ :statements | ",						"\t  statements size = 1",						"\t\t  ifTrue: [ statements first ]",						"\t\t  ifFalse: [ ",						"\t\t\t  Error signal:",						"\t\t\t\t  ('Assumption that {} has 1 statement only is violated.' format:",						"\t\t\t\t\t   { self }) ] ]"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 803916,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#substituteVariablesUsingSequenceableCollection:",				"TheLittleProver>>#equalIfº",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_44",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_49",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46_variablesBindingManually",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_19",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46_variablesBindingByEqualSameº"			]		},		"arguments_testSenderoBackwards" : {			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"arguments_testSenderoBackwards",						"",						"\t| receiverNode messageNodes |",						"\t\"Preparing expected objects.\"",						"\treceiverNode := 0 asReifiedVar asRBNode.",						"\tmessageNodes := { ",						"\t\t                (RBMessageNode",						"\t\t\t                 receiver: receiverNode",						"\t\t\t                 selector: #numberOfEdges).",						"\t\t                (RBMessageNode",						"\t\t\t                 receiver: receiverNode",						"\t\t\t                 selector: #testStackedVertically).",						"\t\t                (RBMessageNode",						"\t\t\t                 receiver: receiverNode",						"\t\t\t                 selector: #iconicHaloSpecifications).",						"\t\t                (RBMessageNode",						"\t\t\t                 receiver: receiverNode",						"\t\t\t                 selector: #packageModels).",						"\t\t                (RBMessageNode",						"\t\t\t                 receiver: receiverNode",						"\t\t\t                 selector: #testReversed) }.",						"",						"\tself",						"\t\tassert: ([ :aSend | ",						"\t\t\t [ :o :ast | ast sendso value: aSend ] asGoalWithASTof: [ :o | o ] ]",						"\t\t\t\t asGoal solutions next: messageNodes size)",						"\t\tequals: messageNodes",						"\t\tmodulo: #asOrderedCollection.",						"",						"\t^ { ",						"\t\t  receiverNode.",						"\t\t  messageNodes }"					],					"body" : [						"| receiverNode messageNodes |",						"\"Preparing expected objects.\"",						"receiverNode := 0 asReifiedVar asRBNode.",						"messageNodes := { ",						"\t                (RBMessageNode",						"\t\t                 receiver: receiverNode",						"\t\t                 selector: #numberOfEdges).",						"\t                (RBMessageNode",						"\t\t                 receiver: receiverNode",						"\t\t                 selector: #testStackedVertically).",						"\t                (RBMessageNode",						"\t\t                 receiver: receiverNode",						"\t\t                 selector: #iconicHaloSpecifications).",						"\t                (RBMessageNode",						"\t\t                 receiver: receiverNode",						"\t\t                 selector: #packageModels).",						"\t                (RBMessageNode",						"\t\t                 receiver: receiverNode",						"\t\t                 selector: #testReversed) }.",						"",						"self",						"\tassert: ([ :aSend | ",						"\t\t [ :o :ast | ast sendso value: aSend ] asGoalWithASTof: [ :o | o ] ]",						"\t\t\t asGoal solutions next: messageNodes size)",						"\tequals: messageNodes",						"\tmodulo: #asOrderedCollection.",						"",						"^ { ",						"\t  receiverNode.",						"\t  messageNodes }"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 4701116,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"RBNodePredicatesTest>>#testSenderoBackwards"			]		},		"testSenderoForCompiledMethod" : {			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"testSenderoForCompiledMethod",						"",						"\tself",						"\t\tassert: [ :selector | ",						"\t\t\t(RBProgramNodeSendsoVisitor >> #visitMessageNode:) sendso value:",						"\t\t\t\tselector ] asGoal solutions",						"\t\tequals: { ",						"\t\t\t\t(RBSelectorNode value: #visitMessageNode:).",						"\t\t\t\t(RBSelectorNode value: #unifyo).",						"\t\t\t\t(RBSelectorNode value: #selectorNode).",						"\t\t\t\t(RBSelectorNode value: #value:).",						"\t\t\t\t(RBSelectorNode value: #add:) }",						"\t\tmodulo: #asOrderedCollection"					],					"body" : [						"self",						"\tassert: [ :selector | ",						"\t\t(RBProgramNodeSendsoVisitor >> #visitMessageNode:) sendso value:",						"\t\t\tselector ] asGoal solutions",						"\tequals: { ",						"\t\t\t(RBSelectorNode value: #visitMessageNode:).",						"\t\t\t(RBSelectorNode value: #unifyo).",						"\t\t\t(RBSelectorNode value: #selectorNode).",						"\t\t\t(RBSelectorNode value: #value:).",						"\t\t\t(RBSelectorNode value: #add:) }",						"\tmodulo: #asOrderedCollection"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4177107,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			]		},		"asGoalWithASTof:select:" : {			"implementors" : {				"BlockClosure" : {					"sourceCode" : [						"asGoalWithASTof: aBlock select: selectBlock",						"",						"\t^ self",						"\t\t  asGoalWithASTof: aBlock",						"\t\t  contextVariables: #(  )",						"\t\t  select: selectBlock"					],					"body" : [						"^ self",						"\t  asGoalWithASTof: aBlock",						"\t  contextVariables: #(  )",						"\t  select: selectBlock"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 34882202,					"argumentNames" : [						"aBlock",						"selectBlock"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#asGoalWithASTof:"			]		},		"cons:" : {			"implementors" : {				"IRPushArray" : {					"sourceCode" : [						"cons: aBool",						"",						"\tcons := aBool"					],					"body" : [						"cons := aBool"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 19090586,					"argumentNames" : [						"aBool"					]				},				"SkewBinaryCanonicalNumber" : {					"sourceCode" : [						"cons: i",						"",						"\t^ self cons: i onto: representation"					],					"body" : [						"^ self cons: i onto: representation"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 24395985,					"argumentNames" : [						"i"					]				},				"Object" : {					"sourceCode" : [						"cons: anObj",						"",						"\t^ anObj consedObject: self"					],					"body" : [						"^ anObj consedObject: self"					],					"isTestMethod" : false,					"category" : "*MicroKanren-core",					"comment" : [ ],					"hash" : 18637760,					"argumentNames" : [						"anObj"					]				}			},			"senders" : [				"ArithTest>>#testAddero",				"ArithTest>>#testGreaterThanOneo",				"ArithTheory>>#positiveo",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"Cons>>#collect:",				"ConsTest>>#testPrinting",				"GoalTest>>#testLolo",				"GoalTest>>#testAppendo",				"GoalTest>>#testCaro",				"GoalTest>>#testCdro",				"GoalTest>>#testBagOf",				"IRInstruction class>>#pushConsArray:",				"IRInstruction class>>#pushNewArray:",				"Integer>>#asConsedBinaryRepr:",				"MKPredicateSexpConso>>#goal",				"MKPredicateSexpDycko>>#goal",				"McCullochAssociateRule>>#relateo",				"McCullochIdentityRule>>#relateo",				"McCullochRepeatRule>>#relateo",				"McCullochReverseRule>>#relateo",				"McCullochRightHalfAssociateRule>>#relateo",				"McCullochShrinkRule>>#relateo",				"PredicateBagOfo>>#onState:",				"RBNodeTheoryTest>>#testUnifyLiteralBlock",				"RBNodeTheoryTest>>#testUnifyConsIsAtomBlock",				"Reuse>>#onState:",				"SBRAL>>#at:put:ifAbsent:",				"SkewBinaryCanonicalNumberUnaryFunctionIncrement>>#incrementDifferentAdjacentBits",				"SkewBinaryCanonicalNumberUnaryFunctionIncrement>>#incrementLastDigit",				"SkewBinaryCanonicalNumberUnaryFunctionIncrement>>#incrementZero",				"TheLittleProver>>#cdrOfConsº",				"TheLittleProver>>#carConsº",				"TheLittleProver>>#consº",				"TheLittleProver>>#isAtomConsº",				"TheLittleProver>>#cdrConsº",				"TheLittleProverTest>>#expectedRBNode_chapter_02_frame_7",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_15",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_32",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_55",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_21",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_14",				"TheLittleProverTest>>#flapjackEqualsConsª:isAtomª:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_06",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byBlockClosure",				"TheLittleProverTest>>#consª:isAtomª:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_44",				"TheLittleProverTest>>#expectedRBNode_chapter_02_frame_12",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_backward",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_49",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_07",				"TheLittleProverTest>>#expectedRBNode_chapter_01_frame_55",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_28",				"TheLittleProverTest>>#expectedRBNode_chapter_01_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46_variablesBindingByEqualSameº",				"Walker>>#forCons:"			]		},		"sendso" : {			"implementors" : {				"RBNode" : {					"sourceCode" : [						"sendso",						"",						"\t^ [ :anObject | ",						"\t  RBProgramNodeSendsoVisitor new",						"\t\t  selectorVar: anObject;",						"\t\t  visitNode: self;",						"\t\t  asGoal ]"					],					"body" : [						"^ [ :anObject | ",						"  RBProgramNodeSendsoVisitor new",						"\t  selectorVar: anObject;",						"\t  visitNode: self;",						"\t  asGoal ]"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 1971357,					"argumentNames" : [ ]				},				"BlockClosure" : {					"sourceCode" : [						"sendso",						"",						"\t^ self sourceNode body sendso"					],					"body" : [						"^ self sourceNode body sendso"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 803478,					"argumentNames" : [ ]				},				"CompiledMethod" : {					"sourceCode" : [						"sendso",						"",						"\t^ self sourceNode body sendso"					],					"body" : [						"^ self sourceNode body sendso"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 1587350,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#sendso",				"CompiledMethod>>#sendso",				"RBNodePredicatesTest>>#testSenderoForCompiledMethod",				"RBNodePredicatesTest>>#testSenderoForEmptyBlockClosure",				"RBNodePredicatesTest>>#testSenderoForIdentityBlockClosure",				"RBNodePredicatesTest>>#arguments_testSenderoBackwards",				"RBNodePredicatesTest>>#testSenderoBackwards",				"RBNodePredicatesTest>>#testSenderoForBlockClosure"			]		},		"testSenderoForBlockClosure" : {			"implementors" : {				"RBNodePredicatesTest" : {					"sourceCode" : [						"testSenderoForBlockClosure",						"",						"\t| aBlock |",						"\taBlock := [ :aMessageNode :goals :selectorVar | ",						"\t          super visitMessageNode: aMessageNode.",						"\t          goals add:",						"\t\t          (selectorVar unifyo value: aMessageNode selectorNode) ].",						"\tself",						"\t\tassert:",						"\t\t[ :selector | aBlock sendso value: selector ] asGoal solutions",						"\t\tequals: { ",						"\t\t\t\t(RBSelectorNode value: #visitMessageNode:).",						"\t\t\t\t(RBSelectorNode value: #unifyo).",						"\t\t\t\t(RBSelectorNode value: #selectorNode).",						"\t\t\t\t(RBSelectorNode value: #value:).",						"\t\t\t\t(RBSelectorNode value: #add:) }",						"\t\tmodulo: #asOrderedCollection.",						"",						"\tself deny: (super respondsTo: #visitMessageNode:)"					],					"body" : [						"| aBlock |",						"aBlock := [ :aMessageNode :goals :selectorVar | ",						"          super visitMessageNode: aMessageNode.",						"          goals add:",						"\t          (selectorVar unifyo value: aMessageNode selectorNode) ].",						"self",						"\tassert:",						"\t[ :selector | aBlock sendso value: selector ] asGoal solutions",						"\tequals: { ",						"\t\t\t(RBSelectorNode value: #visitMessageNode:).",						"\t\t\t(RBSelectorNode value: #unifyo).",						"\t\t\t(RBSelectorNode value: #selectorNode).",						"\t\t\t(RBSelectorNode value: #value:).",						"\t\t\t(RBSelectorNode value: #add:) }",						"\tmodulo: #asOrderedCollection.",						"",						"self deny: (super respondsTo: #visitMessageNode:)"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4440752,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			]		},		"visitMessageNode:" : {			"implementors" : {				"RBDumpVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tstream",						"\t\tnextPutAll: aMessageNode class name;",						"\t\tnextPutAll: ' receiver: ('.",						"\taMessageNode receiver acceptVisitor: self.",						"\tstream nextPutAll: ') selector: '.",						"\taMessageNode selector printOn: stream.",						"\taMessageNode arguments ifNotEmpty: [ ",						"\t\tstream nextPutAll: ' arguments: {'.",						"\t\taMessageNode arguments do: [ :each | ",						"\t\t\teach acceptVisitor: self.",						"\t\t\tstream nextPutAll: '. ' ].",						"\t\tstream nextPut: $} ]"					],					"body" : [						"stream",						"\tnextPutAll: aMessageNode class name;",						"\tnextPutAll: ' receiver: ('.",						"aMessageNode receiver acceptVisitor: self.",						"stream nextPutAll: ') selector: '.",						"aMessageNode selector printOn: stream.",						"aMessageNode arguments ifNotEmpty: [ ",						"\tstream nextPutAll: ' arguments: {'.",						"\taMessageNode arguments do: [ :each | ",						"\t\teach acceptVisitor: self.",						"\t\tstream nextPutAll: '. ' ].",						"\tstream nextPut: $} ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19021511,					"argumentNames" : [						"aMessageNode"					]				},				"IconStyler" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tself addIconStyle: aMessageNode.",						"\tsuper visitMessageNode: aMessageNode"					],					"body" : [						"self addIconStyle: aMessageNode.",						"super visitMessageNode: aMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19915523,					"argumentNames" : [						"aMessageNode"					]				},				"CDFluidClassDefinitionParser" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t\"See class comment. Here we handle the cascade version of the class definition.\"",						"",						"\t\"",						"\tObject << #Point",						"\t\t\tpackage: ''Kernel-BasicObjects'''",						"\t\"",						"",						"\tself handleClassAndSuperclassOf: aRBMessageNode.",						"",						"",						"\taRBMessageNode selectorParts",						"\t\twith: aRBMessageNode arguments",						"\t\tdo: [ :selectorPart :argument | ",						"\t\t\tself parseSelectorPart: selectorPart withArgument: argument ]"					],					"body" : [						"self handleClassAndSuperclassOf: aRBMessageNode.",						"",						"",						"aRBMessageNode selectorParts",						"\twith: aRBMessageNode arguments",						"\tdo: [ :selectorPart :argument | ",						"\t\tself parseSelectorPart: selectorPart withArgument: argument ]"					],					"isTestMethod" : false,					"category" : "parsing-internal",					"comment" : [						"See class comment. Here we handle the cascade version of the class definition."					],					"hash" : 22159581,					"argumentNames" : [						"aRBMessageNode"					]				},				"RFASTTranslator" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\taMessageNode isInlined",						"\t\tifTrue: [ ",						"\t\t\tmethodBuilder addLiteral: aMessageNode selector. \"so searching for senders will work\"",						"\t\t\tself emitPreamble: aMessageNode.",						"\t\t\tself emitMetaLinkBefore: aMessageNode.",						"\t\t\taMessageNode hasMetalinkInstead",						"\t\t\t\tifTrue: [ self emitMetaLinkInstead: aMessageNode ]",						"\t\t\t\tifFalse: [ ",						"\t\t\t\t\tself",						"\t\t\t\t\t\tperform: (OptimizedMessages at: aMessageNode selector)",						"\t\t\t\t\t\twith: aMessageNode ].",						"\t\t\tself emitMetaLinkAfterNoEnsure: aMessageNode ]",						"\t\tifFalse: [ self emitMessageNode: aMessageNode ]"					],					"body" : [						"aMessageNode isInlined",						"\tifTrue: [ ",						"\t\tmethodBuilder addLiteral: aMessageNode selector. \"so searching for senders will work\"",						"\t\tself emitPreamble: aMessageNode.",						"\t\tself emitMetaLinkBefore: aMessageNode.",						"\t\taMessageNode hasMetalinkInstead",						"\t\t\tifTrue: [ self emitMetaLinkInstead: aMessageNode ]",						"\t\t\tifFalse: [ ",						"\t\t\t\tself",						"\t\t\t\t\tperform: (OptimizedMessages at: aMessageNode selector)",						"\t\t\t\t\twith: aMessageNode ].",						"\t\tself emitMetaLinkAfterNoEnsure: aMessageNode ]",						"\tifFalse: [ self emitMessageNode: aMessageNode ]"					],					"isTestMethod" : false,					"category" : "visitor-double dispatching",					"comment" : [ ],					"hash" : 20893190,					"argumentNames" : [						"aMessageNode"					]				},				"RBParseTreeRewriter" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\taMessageNode receiver: (self visitNode: aMessageNode receiver).",						"\taMessageNode arguments:",						"\t\t(aMessageNode arguments collect: [ :each | self visitNode: each ])"					],					"body" : [						"aMessageNode receiver: (self visitNode: aMessageNode receiver).",						"aMessageNode arguments:",						"\t(aMessageNode arguments collect: [ :each | self visitNode: each ])"					],					"isTestMethod" : false,					"category" : "visitor-double dispatching",					"comment" : [ ],					"hash" : 19031389,					"argumentNames" : [						"aMessageNode"					]				},				"RBProgramNodeVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\tifTrue: [ self visitNode: aMessageNode receiver ].",						"\taMessageNode arguments do: [ :each | self visitNode: each ]"					],					"body" : [						"(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\tifTrue: [ self visitNode: aMessageNode receiver ].",						"aMessageNode arguments do: [ :each | self visitNode: each ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19009106,					"argumentNames" : [						"aMessageNode"					]				},				"FBDOptimizedMessagesRewriter" : {					"sourceCode" : [						"visitMessageNode: msgNode",						"",						"\t\"Do not add return statements. ",						"\tifTrue:ifFalse: handling may change the current message node into an ifTrue: , an ifFalse: or an ifNil:ifNotNil: message. ",						"\twhileTrue are used to detect to:do: and to: by: do.\"",						"",						"\tsuper visitMessageNode: msgNode.",						"\t(self isReconstructed: msgNode) ifFalse: [ ^ self ].",						"\tmsgNode selector = #ifTrue:ifFalse: ifTrue: [ ",						"\t\tself handleIfTrueIfFalse: msgNode ].",						"\tmsgNode selector = #ifNil:ifNotNil: ifTrue: [ ",						"\t\tself handleIfNilIfNotNil: msgNode ].",						"\tmsgNode selector = #ifTrue: ifTrue: [ self handleIfTrue: msgNode ].",						"\tmsgNode selector = #ifFalse: ifTrue: [ self handleIfFalse: msgNode ].",						"\tmsgNode selector = #whileTrue: ifTrue: [ ",						"\t\tself handleWhileTrue: msgNode ].",						"\t(self isBigArray: msgNode) ifTrue: [ self handleBigArray: msgNode ]"					],					"body" : [						"super visitMessageNode: msgNode.",						"(self isReconstructed: msgNode) ifFalse: [ ^ self ].",						"msgNode selector = #ifTrue:ifFalse: ifTrue: [ ",						"\tself handleIfTrueIfFalse: msgNode ].",						"msgNode selector = #ifNil:ifNotNil: ifTrue: [ ",						"\tself handleIfNilIfNotNil: msgNode ].",						"msgNode selector = #ifTrue: ifTrue: [ self handleIfTrue: msgNode ].",						"msgNode selector = #ifFalse: ifTrue: [ self handleIfFalse: msgNode ].",						"msgNode selector = #whileTrue: ifTrue: [ ",						"\tself handleWhileTrue: msgNode ].",						"(self isBigArray: msgNode) ifTrue: [ self handleBigArray: msgNode ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [						"Do not add return statements. ",						"\tifTrue:ifFalse: handling may change the current message node into an ifTrue: , an ifFalse: or an ifNil:ifNotNil: message. ",						"\twhileTrue are used to detect to:do: and to: by: do."					],					"hash" : 19503619,					"argumentNames" : [						"msgNode"					]				},				"CoMockASTResultSetBuilder" : {					"sourceCode" : [						"visitMessageNode: aNode",						"",						"\theuristic := #message.",						"\t^ super visitMessageNode: aNode"					],					"body" : [						"heuristic := #message.",						"^ super visitMessageNode: aNode"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20700451,					"argumentNames" : [						"aNode"					]				},				"RBProgramNodeSendsoVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tsuper visitMessageNode: aMessageNode.",						"",						"\tgoals add: (selectorVar unifyo value: aMessageNode selectorNode)"					],					"body" : [						"super visitMessageNode: aMessageNode.",						"",						"goals add: (selectorVar unifyo value: aMessageNode selectorNode)"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20684630,					"argumentNames" : [						"aMessageNode"					]				},				"EFFormatter" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tself visitNode: aMessageNode receiver.",						"\tself formatSelectorAndArguments: aMessageNode"					],					"body" : [						"self visitNode: aMessageNode receiver.",						"self formatSelectorAndArguments: aMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20980019,					"argumentNames" : [						"aMessageNode"					]				},				"CDTraitCompositionBuilder" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t| node receiver argument |",						"\taRBMessageNode selector = #classTrait ifTrue: [ ",						"\t\t^ CDClassTraitNode new",						"\t\t\t  originalNode: aRBMessageNode;",						"\t\t\t  name: aRBMessageNode receiver name;",						"\t\t\t  yourself ].",						"",						"\treceiver := aRBMessageNode receiver acceptVisitor: self.",						"\targument := aRBMessageNode arguments first acceptVisitor: self.",						"",						"\tnode := receiver perform: aRBMessageNode selector with: argument.",						"\tnode originalNode: aRBMessageNode.",						"\t^ node"					],					"body" : [						"| node receiver argument |",						"aRBMessageNode selector = #classTrait ifTrue: [ ",						"\t^ CDClassTraitNode new",						"\t\t  originalNode: aRBMessageNode;",						"\t\t  name: aRBMessageNode receiver name;",						"\t\t  yourself ].",						"",						"receiver := aRBMessageNode receiver acceptVisitor: self.",						"argument := aRBMessageNode arguments first acceptVisitor: self.",						"",						"node := receiver perform: aRBMessageNode selector with: argument.",						"node originalNode: aRBMessageNode.",						"^ node"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 22958405,					"argumentNames" : [						"aRBMessageNode"					]				},				"CoTypeInferencer" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t| receiverType |",						"\treceiverType := aRBMessageNode receiver acceptVisitor: self.",						"\t^ self visitMessageNode: aRBMessageNode receiverType: receiverType"					],					"body" : [						"| receiverType |",						"receiverType := aRBMessageNode receiver acceptVisitor: self.",						"^ self visitMessageNode: aRBMessageNode receiverType: receiverType"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23412137,					"argumentNames" : [						"aRBMessageNode"					]				},				"RBSimpleFormatter" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\tself",						"\t\tvisitNode: aMessageNode receiver;",						"\t\tformatSelectorAndArguments: aMessageNode"					],					"body" : [						"self",						"\tvisitNode: aMessageNode receiver;",						"\tformatSelectorAndArguments: aMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19021114,					"argumentNames" : [						"aMessageNode"					]				},				"CDClassDefinitionParser" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t(self isInstanceSideDefinition: aRBMessageNode)",						"\t\tifTrue: [ self handleSuperclassNode: aRBMessageNode receiver ]",						"\t\tifFalse: [ self handleClassName: aRBMessageNode receiver receiver ].",						"",						"\taRBMessageNode selectorParts",						"\t\twith: aRBMessageNode arguments",						"\t\tdo: [ :selectorPart :argument | ",						"\t\t\tself parseSelectorPart: selectorPart withArgument: argument ]"					],					"body" : [						"(self isInstanceSideDefinition: aRBMessageNode)",						"\tifTrue: [ self handleSuperclassNode: aRBMessageNode receiver ]",						"\tifFalse: [ self handleClassName: aRBMessageNode receiver receiver ].",						"",						"aRBMessageNode selectorParts",						"\twith: aRBMessageNode arguments",						"\tdo: [ :selectorPart :argument | ",						"\t\tself parseSelectorPart: selectorPart withArgument: argument ]"					],					"isTestMethod" : false,					"category" : "parsing",					"comment" : [ ],					"hash" : 22160715,					"argumentNames" : [						"aRBMessageNode"					]				},				"CoASTHeuristicsResultSetBuilder" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t^ self",						"\t\t  configureFetcherForNode: aRBMessageNode",						"\t\t  usingHeuristicAvoidingRepetitions: self messageHeuristic"					],					"body" : [						"^ self",						"\t  configureFetcherForNode: aRBMessageNode",						"\t  usingHeuristicAvoidingRepetitions: self messageHeuristic"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23144880,					"argumentNames" : [						"aRBMessageNode"					]				},				"RBProgramNodeWalkVisitor" : {					"sourceCode" : [						"visitMessageNode: aNode",						"",						"\t^ RBMessageNode",						"\t\t  receiver: (aNode receiver acceptVisitor: self)",						"\t\t  selector: (aNode selectorNode acceptVisitor: self)",						"\t\t  arguments:",						"\t\t  (aNode arguments collect: [ :each | each acceptVisitor: self ])"					],					"body" : [						"^ RBMessageNode",						"\t  receiver: (aNode receiver acceptVisitor: self)",						"\t  selector: (aNode selectorNode acceptVisitor: self)",						"\t  arguments:",						"\t  (aNode arguments collect: [ :each | each acceptVisitor: self ])"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20689142,					"argumentNames" : [						"aNode"					]				},				"OCASTTranslator" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\taMessageNode isInlined ifTrue: [ ",						"\t\tmethodBuilder addLiteral: aMessageNode selector. \"so searching for senders will work\"",						"\t\t^ self",						"\t\t\t  perform: (OptimizedMessages at: aMessageNode selector)",						"\t\t\t  with: aMessageNode ].",						"\t^ self emitMessageNode: aMessageNode"					],					"body" : [						"aMessageNode isInlined ifTrue: [ ",						"\tmethodBuilder addLiteral: aMessageNode selector. \"so searching for senders will work\"",						"\t^ self",						"\t\t  perform: (OptimizedMessages at: aMessageNode selector)",						"\t\t  with: aMessageNode ].",						"^ self emitMessageNode: aMessageNode"					],					"isTestMethod" : false,					"category" : "visitor-double dispatching",					"comment" : [ ],					"hash" : 19083763,					"argumentNames" : [						"aMessageNode"					]				},				"CoASTResultSetBuilder" : {					"sourceCode" : [						"visitMessageNode: aRBMessageNode",						"",						"\t^ self visitNode: aRBMessageNode"					],					"body" : [						"^ self visitNode: aRBMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23144128,					"argumentNames" : [						"aRBMessageNode"					]				},				"RBProgramNodeReifyVisitor" : {					"sourceCode" : [						"visitMessageNode: aNode",						"",						"\taNode receiver acceptVisitor: self.",						"\taNode selectorNode acceptVisitor: self.",						"\taNode arguments do: [ :each | each acceptVisitor: self ]"					],					"body" : [						"aNode receiver acceptVisitor: self.",						"aNode selectorNode acceptVisitor: self.",						"aNode arguments do: [ :each | each acceptVisitor: self ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20688881,					"argumentNames" : [						"aNode"					]				},				"OCASTMethodMetadataAnalyser" : {					"sourceCode" : [						"visitMessageNode: aNode",						"",						"\tsuper visitMessageNode: aNode.",						"\taNode isHaltNode ifTrue: [ ",						"\t\taNode methodNode methodPropertyAt: #containsHalt put: true ]"					],					"body" : [						"super visitMessageNode: aNode.",						"aNode isHaltNode ifTrue: [ ",						"\taNode methodNode methodPropertyAt: #containsHalt put: true ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19087748,					"argumentNames" : [						"aNode"					]				},				"RGTraitCompositionVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t| rec args |",						"\trec := self visitNode: aMessageNode receiver.",						"\targs := aMessageNode arguments collect: [ :each | ",						"\t\t        self visitNode: each ].",						"",						"\taMessageNode selector = #+ ifTrue: [ ",						"\t\trec isCollection",						"\t\t\tifTrue: [ rec add: args first ]",						"\t\t\tifFalse: [ ",						"\t\t\t\trec := { ",						"\t\t\t\t\t       rec.",						"\t\t\t\t\t       args first } asOrderedCollection ].",						"\t\t^ rec ].",						"",						"\taMessageNode selector = #- ifTrue: [ ",						"\t\t| exclusion |",						"\t\texclusion := RGTraitExclusion parent: self traitComposition.",						"\t\texclusion pvtSubject: rec.",						"\t\texclusion pvtCleanExclusions.",						"\t\targs first do: [ :each | exclusion pvtAddExclusion: each ].",						"\t\t^ exclusion ].",						"",						"\t\"an Array(Trait2 @ {#c3->#c2})\"",						"\taMessageNode selector = #@ ifTrue: [ ",						"\t\t| exclusion |",						"\t\texclusion := RGTraitAlias parent: self traitComposition.",						"\t\texclusion pvtSubject: rec.",						"\t\texclusion pvtCleanAliases.",						"\t\targs first do: [ :each | exclusion pvtAddAlias: each ].",						"\t\t^ exclusion ].",						"",						"\taMessageNode selector = #-> ifTrue: [ \"for associations in aliases\" ",						"\t\t^ rec -> args first ].",						"",						"\taMessageNode selector = #classTrait ifTrue: [ \"for associations in aliases\"",						"\t\trec classTrait makeResolved.",						"\t\trec classTrait name: rec name , ' classTrait'.",						"\t\t^ rec classTrait ].",						"",						"\tself error: 'Unknown trait composition message'"					],					"body" : [						"| rec args |",						"rec := self visitNode: aMessageNode receiver.",						"args := aMessageNode arguments collect: [ :each | ",						"\t        self visitNode: each ].",						"",						"aMessageNode selector = #+ ifTrue: [ ",						"\trec isCollection",						"\t\tifTrue: [ rec add: args first ]",						"\t\tifFalse: [ ",						"\t\t\trec := { ",						"\t\t\t\t       rec.",						"\t\t\t\t       args first } asOrderedCollection ].",						"\t^ rec ].",						"",						"aMessageNode selector = #- ifTrue: [ ",						"\t| exclusion |",						"\texclusion := RGTraitExclusion parent: self traitComposition.",						"\texclusion pvtSubject: rec.",						"\texclusion pvtCleanExclusions.",						"\targs first do: [ :each | exclusion pvtAddExclusion: each ].",						"\t^ exclusion ].",						"",						"\"an Array(Trait2 @ {#c3->#c2})\"",						"aMessageNode selector = #@ ifTrue: [ ",						"\t| exclusion |",						"\texclusion := RGTraitAlias parent: self traitComposition.",						"\texclusion pvtSubject: rec.",						"\texclusion pvtCleanAliases.",						"\targs first do: [ :each | exclusion pvtAddAlias: each ].",						"\t^ exclusion ].",						"",						"aMessageNode selector = #-> ifTrue: [ \"for associations in aliases\" ",						"\t^ rec -> args first ].",						"",						"aMessageNode selector = #classTrait ifTrue: [ \"for associations in aliases\"",						"\trec classTrait makeResolved.",						"\trec classTrait name: rec name , ' classTrait'.",						"\t^ rec classTrait ].",						"",						"self error: 'Unknown trait composition message'"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 23446276,					"argumentNames" : [						"aMessageNode"					]				},				"SHRBTextStyler" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t| style link |",						"\tstyle := #keyword.",						"",						"\t(Symbol findInternedSelector: aMessageNode selector asString) ifNil: [ ",						"\t\tstyle := self formatIncompleteSelector: aMessageNode ].",						"",						"\tlink := TextMethodLink sourceNode: aMessageNode.",						"\tself styleOpenParenthese: aMessageNode.",						"",						"\taMessageNode selectorParts",						"\t\twith: aMessageNode keywordsPositions",						"\t\tdo: [ :keyword :position | ",						"\t\t\tself",						"\t\t\t\taddStyle: style",						"\t\t\t\tattribute: link",						"\t\t\t\tfrom: position",						"\t\t\t\tto: position + keyword size - 1 ].",						"",						"\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\tifTrue: [ self visitNode: aMessageNode receiver ].",						"",						"\taMessageNode arguments do: [ :each | self visitNode: each ].",						"\tself styleCloseParenthese: aMessageNode"					],					"body" : [						"| style link |",						"style := #keyword.",						"",						"(Symbol findInternedSelector: aMessageNode selector asString) ifNil: [ ",						"\tstyle := self formatIncompleteSelector: aMessageNode ].",						"",						"link := TextMethodLink sourceNode: aMessageNode.",						"self styleOpenParenthese: aMessageNode.",						"",						"aMessageNode selectorParts",						"\twith: aMessageNode keywordsPositions",						"\tdo: [ :keyword :position | ",						"\t\tself",						"\t\t\taddStyle: style",						"\t\t\tattribute: link",						"\t\t\tfrom: position",						"\t\t\tto: position + keyword size - 1 ].",						"",						"(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\tifTrue: [ self visitNode: aMessageNode receiver ].",						"",						"aMessageNode arguments do: [ :each | self visitNode: each ].",						"self styleCloseParenthese: aMessageNode"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 22037664,					"argumentNames" : [						"aMessageNode"					]				},				"TRBProgramNodeVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\tifTrue: [ self visitNode: aMessageNode receiver ].",						"\taMessageNode arguments do: [ :each | self visitNode: each ]"					],					"body" : [						"(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\tifTrue: [ self visitNode: aMessageNode receiver ].",						"aMessageNode arguments do: [ :each | self visitNode: each ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19154258,					"argumentNames" : [						"aMessageNode"					]				},				"RBReadBeforeWrittenTester" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t((#( #whileTrue: #whileFalse: #whileTrue #whileFalse #whileNil: ) ",						"\t\t  includes: aMessageNode selector) and: [ ",						"\t\t aMessageNode receiver isBlock ])",						"\t\tifTrue: [ self executeTree: aMessageNode receiver body ]",						"\t\tifFalse: [ ",						"\t\t\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\t\t\tifTrue: [ self visitNode: aMessageNode receiver ] ].",						"\t((#( #ifTrue:ifFalse: #ifFalse:ifTrue: ) includes:",						"\t\t  aMessageNode selector) and: [ ",						"\t\t aMessageNode arguments allSatisfy: [ :each | each isBlock ] ]) ",						"\t\tifTrue: [ ^ self processIfTrueIfFalse: aMessageNode ].",						"\taMessageNode arguments do: [ :each | self visitNode: each ]"					],					"body" : [						"((#( #whileTrue: #whileFalse: #whileTrue #whileFalse #whileNil: ) ",						"\t  includes: aMessageNode selector) and: [ ",						"\t aMessageNode receiver isBlock ])",						"\tifTrue: [ self executeTree: aMessageNode receiver body ]",						"\tifFalse: [ ",						"\t\t(aMessageNode isCascaded not or: [ aMessageNode isFirstCascaded ]) ",						"\t\t\tifTrue: [ self visitNode: aMessageNode receiver ] ].",						"((#( #ifTrue:ifFalse: #ifFalse:ifTrue: ) includes:",						"\t  aMessageNode selector) and: [ ",						"\t aMessageNode arguments allSatisfy: [ :each | each isBlock ] ]) ",						"\tifTrue: [ ^ self processIfTrueIfFalse: aMessageNode ].",						"aMessageNode arguments do: [ :each | self visitNode: each ]"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 19019901,					"argumentNames" : [						"aMessageNode"					]				},				"RBProgramNodeIdentityVisitor" : {					"sourceCode" : [						"visitMessageNode: aMessageNode",						"",						"\t^ RBMessageNode",						"\t\t  receiver: (aMessageNode receiver acceptVisitor: self)",						"\t\t  selector: aMessageNode selector",						"\t\t  keywordsPositions: aMessageNode keywordsPositions",						"\t\t  arguments:",						"\t\t  (aMessageNode arguments collect: [ :aNode | ",						"\t\t\t   aNode acceptVisitor: self ])"					],					"body" : [						"^ RBMessageNode",						"\t  receiver: (aMessageNode receiver acceptVisitor: self)",						"\t  selector: aMessageNode selector",						"\t  keywordsPositions: aMessageNode keywordsPositions",						"\t  arguments:",						"\t  (aMessageNode arguments collect: [ :aNode | ",						"\t\t   aNode acceptVisitor: self ])"					],					"isTestMethod" : false,					"category" : "visiting",					"comment" : [ ],					"hash" : 20677625,					"argumentNames" : [						"aMessageNode"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"CoMockASTResultSetBuilder>>#visitMessageNode:",				"FBDOptimizedMessagesRewriter>>#visitMessageNode:",				"IconStyler>>#visitMessageNode:",				"OCASTMethodMetadataAnalyser>>#visitMessageNode:",				"RBMessageNode>>#acceptVisitor:",				"RBNodePredicatesTest>>#testSenderoForCompiledMethod",				"RBNodePredicatesTest>>#testSenderoForBlockClosure",				"RBProgramNodeSendsoVisitor>>#visitMessageNode:"			]		},		"substituteVariablesUsingSequenceableCollection:" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#'<~~>'",				"BlockClosure>>#'<~>'",				"BlockClosure>>#'<~~~>'"			],			"implementors" : {				"BlockClosure" : {					"sourceCode" : [						"substituteVariablesUsingSequenceableCollection: rbVariables",						"",						"\t^ self unaryRBNode substituteVariablesUsingDictionary:",						"\t\t  (self argumentNames with: rbVariables collect: #->) asDictionary"					],					"body" : [						"^ self unaryRBNode substituteVariablesUsingDictionary:",						"\t  (self argumentNames with: rbVariables collect: #->) asDictionary"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 17843382,					"argumentNames" : [						"rbVariables"					]				}			}		},		"substituteVariablesUsingDictionary:" : {			"implementors" : {				"RBNode" : {					"sourceCode" : [						"substituteVariablesUsingDictionary: aDict",						"",						"\t^ self acceptVisitor: (RBProgramNodeSubstitutionVisitor new",						"\t\t\t   substitution: aDict;",						"\t\t\t   yourself)"					],					"body" : [						"^ self acceptVisitor: (RBProgramNodeSubstitutionVisitor new",						"\t\t   substitution: aDict;",						"\t\t   yourself)"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 19011526,					"argumentNames" : [						"aDict"					]				}			},			"senders" : [				"ACL>>#rewriting:rewritten:focusAST:focusVar:do:",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BlockClosure>>#substituteVariablesUsingSequenceableCollection:",				"FreshRB>>#onState:withVars:",				"TheLittleProver>>#equalIfº"			]		},		"<~~>" : {			"implementors" : {				"BlockClosure" : {					"sourceCode" : [						"<~~> aBlock",						"",						"\t^ [ :a :b | ",						"\t  [ :ast | ",						"\t  [ :x :y | ",						"\t  | z |",						"\t  z := aBlock substituteVariablesUsingSequenceableCollection:",						"\t\t       (Array with: x with: y).",						"\t  (ast unifyo value: a) , (z unifyo value: b) ] ]",						"\t\t  asGoalWithUnaryASTof: self",						"\t\t  contextVariables: #(  ) ]"					],					"body" : [						"^ [ :a :b | ",						"  [ :ast | ",						"  [ :x :y | ",						"  | z |",						"  z := aBlock substituteVariablesUsingSequenceableCollection:",						"\t       (Array with: x with: y).",						"  (ast unifyo value: a) , (z unifyo value: b) ] ]",						"\t  asGoalWithUnaryASTof: self",						"\t  contextVariables: #(  ) ]"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 17842655,					"argumentNames" : [						"aBlock"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"TheLittleProver>>#carConsº",				"TheLittleProver>>#ifTrueº",				"TheLittleProver>>#isAtomConsº",				"TheLittleProver>>#cdrConsº",				"TheLittleProver>>#equalSwapº",				"TheLittleProver>>#ifFalseº",				"TheLittleProver>>#ifSameº"			]		},		"asLiteralRBNode" : {			"implementors" : {				"Object" : {					"sourceCode" : [						"asLiteralRBNode",						"",						"\t^ self isLiteral",						"\t\t  ifTrue: [ RBLiteralValueNode value: self ]",						"\t\t  ifFalse: [ Error signal: 'I am not a literal value' ]"					],					"body" : [						"^ self isLiteral",						"\t  ifTrue: [ RBLiteralValueNode value: self ]",						"\t  ifFalse: [ Error signal: 'I am not a literal value' ]"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 1599201,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_05_rewriting_unbound",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_32",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_21",				"TheLittleProverTest>>#test_chapter_02_EvenOlderGames_frame_05",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byBlockClosure",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_backward",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_28"			]		},		"<~~~>" : {			"implementors" : {				"BlockClosure" : {					"sourceCode" : [						"<~~~> aBlock",						"",						"\t^ [ :a :b | ",						"\t  [ :ast | ",						"\t  [ :x :y :w | ",						"\t  | z |",						"\t  z := aBlock substituteVariablesUsingSequenceableCollection:",						"\t\t       (Array with: x with: y with: w).",						"\t  (ast unifyo value: a) , (z unifyo value: b) ] ]",						"\t\t  asGoalWithUnaryASTof: self",						"\t\t  contextVariables: #(  ) ]"					],					"body" : [						"^ [ :a :b | ",						"  [ :ast | ",						"  [ :x :y :w | ",						"  | z |",						"  z := aBlock substituteVariablesUsingSequenceableCollection:",						"\t       (Array with: x with: y with: w).",						"  (ast unifyo value: a) , (z unifyo value: b) ] ]",						"\t  asGoalWithUnaryASTof: self",						"\t  contextVariables: #(  ) ]"					],					"isTestMethod" : false,					"category" : "*MicroKanren-RB",					"comment" : [ ],					"hash" : 17842655,					"argumentNames" : [						"aBlock"					]				}			},			"senders" : [				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc"			]		}	}}