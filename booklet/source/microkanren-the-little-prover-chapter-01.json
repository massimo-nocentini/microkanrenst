{	"classes" : {		"TheLittleProver" : {			"hash" : 3384064,			"definition" : "Object subclass: #TheLittleProver\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-ACL'",			"comment" : [				"I contains theorems described in \"The Littler Prover\"."			],			"category" : "MicroKanren-ACL"		},		"TheLittleProverTest" : {			"hash" : 2836736,			"definition" : "Srfi41AbstractTest subclass: #TheLittleProverTest\r\tinstanceVariableNames: 'theory'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-Tests'",			"comment" : [				"A RBProgramNodeIdentityVisitorTest is a test class for testing the behavior of RBProgramNodeIdentityVisitor"			],			"category" : "MicroKanren-Tests"		},		"Object" : {			"hash" : 804608,			"definition" : "ProtoObject subclass: #Object\r\tinstanceVariableNames: ''\r\tclassVariableNames: 'DependentsFields'\r\tpackage: 'Kernel-Objects'",			"comment" : [				"`Object` is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.",				"",				"Class `Object` provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.",				"",				"`Object` has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.",				"",				"Class Variables:",				"\tDependentsFields\t\tan IdentityDictionary",				"\t\tProvides a virtual 'dependents' field so that any object may have one",				"\t\tor more dependent views, synchronized by the changed:/update: protocol.",				"\t\tNote that class Model has a real slot for its dependents, and overrides",				"\t\tthe associated protocol with more efficient implementations.",				"",				"Because `Object` is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.",				"",				"",				"###Miscellanous Discussions",				"",				"About `at:` index accepting float and not only integers",				" ",				"This behavior is also free in the sense that the failure code is only invoked when the primitive fails and so adds nothing to the cost of successful accesses, which are the high dynamic frequency operation.  It will also show up under",				"profiling if one is concerned about efficiency, and so isn't a hidden cost.",				"",				"It is also in keeping with Pharo's mixed mode/arbitrary precision",				"implicit coercion number system that one *can* use fractions or floats as",				"indices.  Stripping out coercions like this will make the system more brittle.  So ",				"please do *not* remove this hack.  I think it's a feature and a useful one.",				"",				"Can you give me an example that demonstrates the usefulness of this feature?",				"",				"```",				"| a r |",				"a := Array new: 10 withAll: 0.",				"r := Random new.",				"100 timesRepeat: [| v | v := r next * 10 + 1. a at: v put: (a at: v) + 1].",				"a",				"```",				"",				"i.e. I didn't have to provide an explicit rounding step.  That's useful.  But in general anywhere ",				"where an index is derived by some calculation not having to provide the rounding step could be ",				"useful/helpful/more concise.  e.g. (n roundTo: 0.1) * 10 vs ((n roundTo: 0.1) * 10) asInteger.",				"",				"Some thought went into the original choice.  It is not a hack but there by intent.  The integers are ",				"simply a subset of the reals and forcing the programmer to use them is favouring the machine ",				"above the programmer.",				"",				"But I think you should justify getting rid of it rather than my having to justify keeping it.  Getting ",				"rid of it risks breaking code.  If it is there but does not harm then why get rid of it?",				"",				"best Eliot Miranda "			],			"category" : "Kernel-Objects"		},		"Cons" : {			"hash" : 6571520,			"definition" : "Object subclass: #Cons\r\tinstanceVariableNames: 'car cdr'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Cons'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tcar:\t\t<Object>",				"\tcdr:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Collections-Sequenceable-Cons"		}	},	"messages" : {		"cdrConsº" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_32",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_56",				"TheLittleProverTest>>#proofStep2:frame29:ast:",				"TheLittleProverTest>>#proofStep1:frame33:ast:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_28"			],			"implementors" : {				"TheLittleProver" : {					"sourceCode" : [						"cdrConsº",						"",						"\t\"(dethm cdr/cons (x y)",						"\t\t(equal (cdr (cons x y)) y))\"",						"",						"\t^ [ :x :y | (x cons: y) cdr ] ··> [ :x :y | y ]"					],					"body" : [						"^ [ :x :y | (x cons: y) cdr ] ··> [ :x :y | y ]"					],					"isTestMethod" : false,					"category" : "predicates",					"comment" : [						"(dethm cdr/cons (x y)",						"\t\t(equal (cdr (cons x y)) y))"					],					"hash" : 4178255,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_11" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_11",						"",						"\t\"(atom '())\"",						"",						"\tself assert: nil isAtom equals: true"					],					"body" : [						"self assert: nil isAtom equals: true"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"(atom '())"					],					"hash" : 3630997,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_16_backward" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_16_backward",						"",						"\t| aGoal node |",						"\taGoal := [ :ast | ",						"\t         [ :a | ",						"\t         theory isAtomConsº value: ast value: false asLiteralRBNode ] ] ",						"\t\t         asGoalWithUnaryASTof: [ :a | a isAtom ].",						"",						"\tnode := RBMessageNode",						"\t\t        receiver: 0 asReifiedVar asRBNode",						"\t\t        selector: #cons:",						"\t\t        arguments: { 1 asReifiedVar asRBNode }.",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node asString equals: 'RBMessageNode(•₀ cons: •₁)'"					],					"body" : [						"| aGoal node |",						"aGoal := [ :ast | ",						"         [ :a | ",						"         theory isAtomConsº value: ast value: false asLiteralRBNode ] ] ",						"\t         asGoalWithUnaryASTof: [ :a | a isAtom ].",						"",						"node := RBMessageNode",						"\t        receiver: 0 asReifiedVar asRBNode",						"\t        selector: #cons:",						"\t        arguments: { 1 asReifiedVar asRBNode }.",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node asString equals: 'RBMessageNode(•₀ cons: •₁)'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4159169,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_46_variablesBindingByEqualSameº" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_46_variablesBindingByEqualSameº",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :car :cdr | ",						"\t         [ :r | ",						"\t         | g1 g2 |",						"\t         g1 := theory equalSameº value: ast value: r asRBNode.",						"\t         g2 := rewritten asRBNode unifyo value:",						"\t\t               (RBMessageNode",						"\t\t\t                receiver: car",						"\t\t\t                selector: #cons:",						"\t\t\t                arguments: { cdr }).",						"\t         g1 , g2 ] asGoal ] ] asGoalWithUnaryASTof: [ :a :d | ",						"\t\t         (#and cons: d) = (a cons: nil) ] ] asGoal.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { [ #and cons: nil ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :car :cdr | ",						"         [ :r | ",						"         | g1 g2 |",						"         g1 := theory equalSameº value: ast value: r asRBNode.",						"         g2 := rewritten asRBNode unifyo value:",						"\t               (RBMessageNode",						"\t\t                receiver: car",						"\t\t                selector: #cons:",						"\t\t                arguments: { cdr }).",						"         g1 , g2 ] asGoal ] ] asGoalWithUnaryASTof: [ :a :d | ",						"\t         (#and cons: d) = (a cons: nil) ] ] asGoal.",						"",						"self",						"\tassert: aGoal solutions asArray",						"\tequals: { [ #and cons: nil ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_49" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_49",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | o ] do: theory equalSwapº;",						"\t\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :x :y | ",						"\t\t         (x cons: y) = (#bagels cons: (#and cons: (#lox cons: nil))) ] ]",						"\t\t         asGoal.",						"",						"\tnode := RBMessageNode",						"\t\t        receiver:",						"\t\t        [ (#bagels cons: (#and cons: (#lox cons: nil))) ]",						"\t\t\t        unaryRBNode",						"\t\t        selector: #=",						"\t\t        arguments: { (RBMessageNode",						"\t\t\t\t         receiver: 0 asReifiedVar asRBNode",						"\t\t\t\t         selector: #cons:",						"\t\t\t\t         arguments: { 1 asReifiedVar asRBNode }) }.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node asString",						"\t\tequals:",						"\t\t\t'RBMessageNode((#bagels cons: (#and cons: (#lox cons: nil))) = (•₀ cons: •₁))'"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | o ] do: theory equalSwapº;",						"\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :x :y | ",						"\t         (x cons: y) = (#bagels cons: (#and cons: (#lox cons: nil))) ] ]",						"\t         asGoal.",						"",						"node := RBMessageNode",						"\t        receiver:",						"\t        [ (#bagels cons: (#and cons: (#lox cons: nil))) ] unaryRBNode",						"\t        selector: #=",						"\t        arguments: { (RBMessageNode",						"\t\t\t         receiver: 0 asReifiedVar asRBNode",						"\t\t\t         selector: #cons:",						"\t\t\t         arguments: { 1 asReifiedVar asRBNode }) }.",						"",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node asString",						"\tequals:",						"\t\t'RBMessageNode((#bagels cons: (#and cons: (#lox cons: nil))) = (•₀ cons: •₁))'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157309,					"argumentNames" : [ ]				}			}		},		"carConsº" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_46",				"TheLittleProverTest>>#proofStep1:frame29:ast:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_55",				"TheLittleProverTest>>#proofStep2:frame44:ast:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_28"			],			"implementors" : {				"TheLittleProver" : {					"sourceCode" : [						"carConsº",						"",						"\t\"(dethm car/cons (x y)",						"\t\t(equal (car (cons x y)) x))\"",						"",						"\t^ [ :x :y | (x cons: y) car ] ··> [ :x :y | x ]"					],					"body" : [						"^ [ :x :y | (x cons: y) car ] ··> [ :x :y | x ]"					],					"isTestMethod" : false,					"category" : "predicates",					"comment" : [						"(dethm car/cons (x y)",						"\t\t(equal (car (cons x y)) x))"					],					"hash" : 4178255,					"argumentNames" : [ ]				}			}		},		"isAtomConsº" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#proofStep1:frame21:ast:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_21",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byBlockClosure",				"TheLittleProverTest>>#flapjackEqualsConsº:isAtomº:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_backward",				"TheLittleProverTest>>#consº:isAtomº:"			],			"implementors" : {				"TheLittleProver" : {					"sourceCode" : [						"isAtomConsº",						"",						"\t\"(dethm atom/cons (x y)",						"\t  (equal (atom (cons x y)) 'nil))\"",						"",						"\t^ [ :x :y | (x cons: y) isAtom ]",						"\t  ··> [ :x :y | false asLiteralRBNode ]"					],					"body" : [						"^ [ :x :y | (x cons: y) isAtom ] ··> [ :x :y | false asLiteralRBNode ]"					],					"isTestMethod" : false,					"category" : "predicates",					"comment" : [						"(dethm atom/cons (x y)",						"\t  (equal (atom (cons x y)) 'nil))"					],					"hash" : 4178255,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_56" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_56",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :x :y :a :b :c | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | y cons: o = (x isAtom = false) ]",						"\t\t\t\t         do: [ :o :r | theory carConsº value: r value: o ].",						"",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         y cons:",						"\t\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t\t         = (x isAtom = o) ]",						"\t\t\t\t         do: [ :o :r | theory isAtomConsº value: r value: o ].",						"",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         y cons:",						"\t\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t\t         = (x isAtom = (o isAtom cons: (a cons: b) = c) isAtom) ]",						"\t\t\t\t         do: [ :o :r | theory cdrConsº value: o value: r ].",						"",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         y cons:",						"\t\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t\t         = (x isAtom = (b isAtom cons: o) isAtom) ]",						"\t\t\t\t         do: [ :o :r | theory equalSwapº value: o value: r ].",						"",						"\t\t\t         rewrite then: [ :o | ",						"\t\t\t\t         theory unifyº value: o value: rewritten asRBNode ] ]",						"\t\t         contextVariables: (OrderedCollection new",						"\t\t\t\t          add: x;",						"\t\t\t\t          add: y;",						"\t\t\t\t          add: a;",						"\t\t\t\t          add: b;",						"\t\t\t\t          add: c;",						"\t\t\t\t          yourself) ] ] asGoalWithUnaryASTof: [ :x :y :a :b :c | ",						"\t\t         y cons: (x cdr cons: y car) car = (x isAtom = false) ] ]",						"\t\t         asGoal.",						"",						"\tnode := self expectedRBNode_frame_56.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node asString",						"\t\tequals:",						"\t\t\t'RBMessageNode(•₀ cons: ((•₁ cdr cons: •₀ car) car cons: (#oats cons: nil)) car",						"\t= (•₁ isAtom = (•₂ isAtom cons: •₃ = (•₄ cons: •₂)) isAtom))'"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :x :y :a :b :c | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | y cons: o = (x isAtom = false) ]",						"\t\t\t         do: [ :o :r | theory carConsº value: r value: o ].",						"",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         y cons:",						"\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t         = (x isAtom = o) ]",						"\t\t\t         do: [ :o :r | theory isAtomConsº value: r value: o ].",						"",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         y cons:",						"\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t         = (x isAtom = (o isAtom cons: (a cons: b) = c) isAtom) ]",						"\t\t\t         do: [ :o :r | theory cdrConsº value: o value: r ].",						"",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         y cons:",						"\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t         = (x isAtom = (b isAtom cons: o) isAtom) ]",						"\t\t\t         do: [ :o :r | theory equalSwapº value: o value: r ].",						"",						"\t\t         rewrite then: [ :o | ",						"\t\t\t         theory unifyº value: o value: rewritten asRBNode ] ]",						"\t         contextVariables: (OrderedCollection new",						"\t\t\t          add: x;",						"\t\t\t          add: y;",						"\t\t\t          add: a;",						"\t\t\t          add: b;",						"\t\t\t          add: c;",						"\t\t\t          yourself) ] ] asGoalWithUnaryASTof: [ :x :y :a :b :c | ",						"\t         y cons: (x cdr cons: y car) car = (x isAtom = false) ] ]",						"\t         asGoal.",						"",						"node := self expectedRBNode_frame_56.",						"",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node asString",						"\tequals:",						"\t\t'RBMessageNode(•₀ cons: ((•₁ cdr cons: •₀ car) car cons: (#oats cons: nil)) car",						"\t= (•₁ isAtom = (•₂ isAtom cons: •₃ = (•₄ cons: •₂)) isAtom))'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157579,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_14" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_14",						"",						"\t\"(atom (cons 'ham '(eggs)))\"",						"",						"\tself assert: (#ham cons: (#eggs cons: nil)) isAtom equals: false"					],					"body" : [						"self assert: (#ham cons: (#eggs cons: nil)) isAtom equals: false"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"(atom (cons 'ham '(eggs)))"					],					"hash" : 3631416,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_32" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_32",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | o isAtom ] do: theory cdrConsº;",						"\t\t\t\t         focus: [ :o | o ] do: theory isAtomNilº;",						"\t\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :p :q | ",						"\t\t         ((p cons: q) car cons: nil) cdr isAtom ] ] asGoal.",						"",						"\tself assert: aGoal solutions asArray equals: { [ true ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | o isAtom ] do: theory cdrConsº;",						"\t\t\t         focus: [ :o | o ] do: theory isAtomNilº;",						"\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :p :q | ",						"\t         ((p cons: q) car cons: nil) cdr isAtom ] ] asGoal.",						"",						"self assert: aGoal solutions asArray equals: { [ true ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_16_byBlockClosure" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_16_byBlockClosure",						"",						"\t| aGoal |",						"\taGoal := [ :rewrite | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         theory isAtomConsº value: ast value: rewrite asRBNode ] ] ",						"\t\t         asGoalWithUnaryASTof: [ :a :b | (a cons: b) isAtom ] ]",						"\t\t         asGoal.",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { [ false ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewrite | ",						"         [ :ast | ",						"         [ :a :b | ",						"         theory isAtomConsº value: ast value: rewrite asRBNode ] ] ",						"\t         asGoalWithUnaryASTof: [ :a :b | (a cons: b) isAtom ] ]",						"\t         asGoal.",						"self assert: aGoal solutions asArray equals: { [ false ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_06" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_06",						"",						"\t\"(car (cons 'ham '(eggs)))\"",						"",						"\tself assert: (#ham cons: (#eggs cons: nil)) car equals: #ham"					],					"body" : [						"self assert: (#ham cons: (#eggs cons: nil)) car equals: #ham"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"(car (cons 'ham '(eggs)))"					],					"hash" : 3631370,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod",						"",						"\t| aGoal |",						"\taGoal := [ :rewrite | ",						"\t         [ :ast | self consº: ast isAtomº: rewrite asRBNode ] ",						"\t\t         asGoalWithUnaryASTof: self class >> #consª:isAtomª: ]",						"\t\t         asGoal.",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { [ false ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewrite | ",						"         [ :ast | self consº: ast isAtomº: rewrite asRBNode ] ",						"\t         asGoalWithUnaryASTof: self class >> #consª:isAtomª: ] asGoal.",						"self assert: aGoal solutions asArray equals: { [ false ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_19" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_19",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         self flapjackEqualsConsº: ast isAtomº: rewritten asRBNode ] ",						"\t\t         asGoalWithUnaryASTof:",						"\t\t         self class >> #flapjackEqualsConsª:isAtomª: ] asGoal.",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { [ #flapjack = false ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         self flapjackEqualsConsº: ast isAtomº: rewritten asRBNode ] ",						"\t         asGoalWithUnaryASTof:",						"\t         self class >> #flapjackEqualsConsª:isAtomª: ] asGoal.",						"self",						"\tassert: aGoal solutions asArray",						"\tequals: { [ #flapjack = false ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_21" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_21",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | #flapjack = o ] do: theory isAtomConsº;",						"\t\t\t\t         focus: [ :o | o ] do: self flapjackNilFalseº;",						"\t\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :a :b | ",						"\t\t         #flapjack = (a cons: b) isAtom ] ] asGoal.",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { [ false ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | #flapjack = o ] do: theory isAtomConsº;",						"\t\t\t         focus: [ :o | o ] do: self flapjackNilFalseº;",						"\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :a :b | ",						"\t         #flapjack = (a cons: b) isAtom ] ] asGoal.",						"self assert: aGoal solutions asArray equals: { [ false ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_28" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_28",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | (o cons: nil) cdr isAtom ]",						"\t\t\t\t         do: theory carConsº;",						"\t\t\t\t         focus: [ :o | o isAtom ] do: theory cdrConsº;",						"\t\t\t\t         focus: [ :o | o ] do: theory isAtomNilº;",						"\t\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :p :q | ",						"\t\t         ((p cons: q) car cons: nil) cdr isAtom ] ] asGoal.",						"",						"\tself assert: aGoal solutions asArray equals: { [ true ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | (o cons: nil) cdr isAtom ]",						"\t\t\t         do: theory carConsº;",						"\t\t\t         focus: [ :o | o isAtom ] do: theory cdrConsº;",						"\t\t\t         focus: [ :o | o ] do: theory isAtomNilº;",						"\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :p :q | ",						"\t         ((p cons: q) car cons: nil) cdr isAtom ] ] asGoal.",						"",						"self assert: aGoal solutions asArray equals: { [ true ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_46_variablesBindingManually" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_46_variablesBindingManually",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         (rewritten asRBNode unifyo value:",						"\t\t          (RBMessageNode receiver: a selector: #even))",						"\t         , ((RBLiteralValueNode value: 3) unifyo value: a) ] ] ",						"\t\t         asGoalWithUnaryASTof: [ :a :b | a + b ] ] asGoal.",						"\tself",						"\t\tassert: aGoal solutions",						"\t\tequals: { [ 3 even ] unaryRBNode }",						"\t\tmodulo: #asOrderedCollection"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         (rewritten asRBNode unifyo value:",						"\t          (RBMessageNode receiver: a selector: #even))",						"         , ((RBLiteralValueNode value: 3) unifyo value: a) ] ] ",						"\t         asGoalWithUnaryASTof: [ :a :b | a + b ] ] asGoal.",						"self",						"\tassert: aGoal solutions",						"\tequals: { [ 3 even ] unaryRBNode }",						"\tmodulo: #asOrderedCollection"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894639,					"argumentNames" : [ ]				}			}		},		"equalSwapº" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_49"			],			"implementors" : {				"TheLittleProver" : {					"sourceCode" : [						"equalSwapº",						"",						"\t\"(dethm equal-swap (x y)",						"\t\t(equal (equal x y) (equal y x)))\"",						"",						"\t^ [ :x :y | x = y ]",						"\t  ··> [ :x :y | ",						"\t  RBMessageNode receiver: y selector: #= arguments: { x } ]"					],					"body" : [						"^ [ :x :y | x = y ]",						"  ··> [ :x :y | ",						"  RBMessageNode receiver: y selector: #= arguments: { x } ]"					],					"isTestMethod" : false,					"category" : "predicates",					"comment" : [						"(dethm equal-swap (x y)",						"\t\t(equal (equal x y) (equal y x)))"					],					"hash" : 4178255,					"argumentNames" : [ ]				}			}		},		"isAtom" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"RBNodeTheoryTest>>#testUnifyConsIsAtomBlock",				"TheLittleProver>>#isAtomNilº",				"TheLittleProver>>#isAtomConsº",				"TheLittleProverTest>>#consCarCdro",				"TheLittleProverTest>>#proofStep1:frame29:ast:",				"TheLittleProverTest>>#cons:carcdr:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_32",				"TheLittleProverTest>>#expectedRBNode_frame_55",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_55",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_21",				"TheLittleProverTest>>#isAtomConso",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_14",				"TheLittleProverTest>>#flapjackEqualsConsª:isAtomª:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byBlockClosure",				"TheLittleProverTest>>#consª:isAtomª:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_backward",				"TheLittleProverTest>>#proofStep2:frame29:ast:",				"TheLittleProverTest>>#expectedRBNode_frame_56",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_11",				"TheLittleProverTest>>#proofStep1:frame33:ast:",				"TheLittleProverTest>>#isAtom:conso:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_28"			],			"implementors" : {				"Cons" : {					"sourceCode" : [						"isAtom",						"",						"\t^ false"					],					"body" : [						"^ false"					],					"isTestMethod" : false,					"category" : "testing",					"comment" : [ ],					"hash" : 7430796,					"argumentNames" : [ ]				},				"Object" : {					"sourceCode" : [						"isAtom",						"",						"\t^ true"					],					"body" : [						"^ true"					],					"isTestMethod" : false,					"category" : "*Collections-Sequenceable-Cons",					"comment" : [ ],					"hash" : 1663882,					"argumentNames" : [ ]				}			}		},		"consª:isAtomª:" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"consª: a isAtomª: b",						"",						"\t(a cons: b) isAtom"					],					"body" : [						"(a cons: b) isAtom"					],					"isTestMethod" : false,					"category" : "code as data",					"comment" : [ ],					"hash" : 37709597,					"argumentNames" : [						"a",						"b"					]				}			}		},		"consº:isAtomº:" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"consº: ast isAtomº: rewritten",						"",						"\t^ [ :a :b | theory isAtomConsº value: ast value: rewritten ]"					],					"body" : [						"^ [ :a :b | theory isAtomConsº value: ast value: rewritten ]"					],					"isTestMethod" : false,					"category" : "predicates",					"comment" : [ ],					"hash" : 37709346,					"argumentNames" : [						"ast",						"rewritten"					]				}			}		},		"flapjackEqualsConsº:isAtomº:" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_19"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"flapjackEqualsConsº: ast isAtomº: rewritten",						"",						"\t^ [ :a :b | ",						"\t  ast",						"\t\t  acl: [ :prover | ",						"\t\t\t  prover",						"\t\t\t\t  focus: [ :o | #flapjack = o ] do: theory isAtomConsº;",						"\t\t\t\t  then: [ :o | o unifyo value: rewritten ] ]",						"\t\t  contextVariables: #(  ) ]"					],					"body" : [						"^ [ :a :b | ",						"  ast",						"\t  acl: [ :prover | ",						"\t\t  prover",						"\t\t\t  focus: [ :o | #flapjack = o ] do: theory isAtomConsº;",						"\t\t\t  then: [ :o | o unifyo value: rewritten ] ]",						"\t  contextVariables: #(  ) ]"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 37709346,					"argumentNames" : [						"ast",						"rewritten"					]				}			}		},		"flapjackEqualsConsª:isAtomª:" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_19"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"flapjackEqualsConsª: a isAtomª: b",						"",						"\t#flapjack = (a cons: b) isAtom"					],					"body" : [						"#flapjack = (a cons: b) isAtom"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 37709752,					"argumentNames" : [						"a",						"b"					]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_46" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_46",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t         (o cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\t\t         do: theory equalSameº.",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | o ] do: theory carConsº;",						"\t\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :x :y | ",						"\t\t         ((x cons: y) = (x cons: y) cons:",						"\t\t\t          (#and cons: (#crumpets cons: nil))) car ] ] asGoal.",						"",						"\tself assert: aGoal solutions asArray equals: { [ true ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t         (o cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\t         do: theory equalSameº.",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | o ] do: theory carConsº;",						"\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :x :y | ",						"\t         ((x cons: y) = (x cons: y) cons:",						"\t\t          (#and cons: (#crumpets cons: nil))) car ] ] asGoal.",						"",						"self assert: aGoal solutions asArray equals: { [ true ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"isAtomNilº" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_32",				"TheLittleProverTest>>#proofStep3:frame29:ast:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_28"			],			"implementors" : {				"TheLittleProver" : {					"sourceCode" : [						"isAtomNilº",						"",						"\t\"",						"\t(dethm atom/nil (x y)",						"\t  (equal (atom 'nil) 't))\"",						"",						"\t^ [ :_ | nil isAtom ] ·> [ :_ | true asLiteralRBNode ]"					],					"body" : [						"^ [ :_ | nil isAtom ] ·> [ :_ | true asLiteralRBNode ]"					],					"isTestMethod" : false,					"category" : "predicates",					"comment" : [						"",						"\t(dethm atom/nil (x y)",						"\t  (equal (atom 'nil) 't))"					],					"hash" : 4178255,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_55" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_55",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :x :y | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | y cons: o = (x isAtom = false) ]",						"\t\t\t\t         do: [ :o :r | theory carConsº value: r value: o ];",						"\t\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t\t         contextVariables: (Array with: x with: y) ] ] ",						"\t\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t\t         y cons: (x cdr cons: y car) car = (x isAtom = false) ] ]",						"\t\t         asGoal.",						"",						"\tnode := self expectedRBNode_frame_55.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node asString equals: 'RBMessageNode(•₀ cons:",						"\t((•₁ cdr cons: •₀ car) car cons: •₂) car = (•₁ isAtom = false))'"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :x :y | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | y cons: o = (x isAtom = false) ]",						"\t\t\t         do: [ :o :r | theory carConsº value: r value: o ];",						"\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t         contextVariables: (Array with: x with: y) ] ] ",						"\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t         y cons: (x cdr cons: y car) car = (x isAtom = false) ] ]",						"\t         asGoal.",						"",						"node := self expectedRBNode_frame_55.",						"",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node asString equals: 'RBMessageNode(•₀ cons:",						"\t((•₁ cdr cons: •₀ car) car cons: •₂) car = (•₁ isAtom = false))'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157579,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_44" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_44",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         (o cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\t\t         do: theory equalSameº;",						"\t\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :x :y | ",						"\t\t         ((x cons: y) = (x cons: y) cons:",						"\t\t\t          (#and cons: (#crumpets cons: nil))) car ] ] asGoal.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals:",						"\t\t{ [ (true cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\tunaryRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         (o cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\t         do: theory equalSameº;",						"\t\t\t         then: [ :o | o unifyo value: rewritten asRBNode ] ]",						"\t         contextVariables: #(  ) ] ] asGoalWithUnaryASTof: [ :x :y | ",						"\t         ((x cons: y) = (x cons: y) cons:",						"\t\t          (#and cons: (#crumpets cons: nil))) car ] ] asGoal.",						"",						"self",						"\tassert: aGoal solutions asArray",						"\tequals:",						"\t{ [ (true cons: (#and cons: (#crumpets cons: nil))) car ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894615,					"argumentNames" : [ ]				}			}		},		"flapjackNilFalseº" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"TheLittleProverTest>>#proofStep2:frame21:ast:",				"TheLittleProverTest>>#test_chapter_01_OldGamesNewRules_frame_21"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"flapjackNilFalseº",						"",						"\t^ [ :a :b | ",						"\t  [ :ast1 | ",						"\t  [ ",						"\t  | g1 g2 |",						"\t  g1 := a unifyo value: ast1.",						"\t  g2 := [ :ast2 | [ b unifyo value: ast2 ] ] asGoalWithUnaryASTof: [ ",						"\t\t        false ].",						"\t  g1 , g2 ] ] asGoalWithUnaryASTof: [ #flapjack = false ] ]"					],					"body" : [						"^ [ :a :b | ",						"  [ :ast1 | ",						"  [ ",						"  | g1 g2 |",						"  g1 := a unifyo value: ast1.",						"  g2 := [ :ast2 | [ b unifyo value: ast2 ] ] asGoalWithUnaryASTof: [ ",						"\t        false ].",						"  g1 , g2 ] ] asGoalWithUnaryASTof: [ #flapjack = false ] ]"					],					"isTestMethod" : false,					"category" : "predicates",					"comment" : [ ],					"hash" : 3630493,					"argumentNames" : [ ]				}			}		}	}}