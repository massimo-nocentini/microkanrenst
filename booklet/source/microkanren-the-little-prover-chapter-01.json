{	"classes" : {		"TheLittleProverTest" : {			"hash" : 2836736,			"definition" : "GoalAbstractTest subclass: #TheLittleProverTest\r\tinstanceVariableNames: 'theory'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-Tests'",			"comment" : [				"A RBProgramNodeIdentityVisitorTest is a test class for testing the behavior of RBProgramNodeIdentityVisitor"			],			"category" : "MicroKanren-Tests"		}	},	"messages" : {		"test_chapter_01_OldGamesNewRules_frame_16" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_16",						"",						"\t| aGoal |",						"\taGoal := [ :rewrite | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         theory isAtomConsº value: ast value: rewrite asRBNode ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :b | (a cons: b) isAtom ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { false asLiteralRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewrite | ",						"         [ :ast | ",						"         [ :a :b | ",						"         theory isAtomConsº value: ast value: rewrite asRBNode ] ]",						"\t         asGoalWithUnaryASTof: [ :a :b | (a cons: b) isAtom ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"self assert: aGoal solutions asArray equals: { false asLiteralRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894806,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_46_variablesBindingManually" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_46_variablesBindingManually",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         (rewritten asRBNode unifyo value:",						"\t\t          (RBMessageNode receiver: a asRBNode selector: #even))",						"\t         , ((RBLiteralValueNode value: 3) unifyo value: a asRBNode) ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :b | a + b ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"\tself",						"\t\tassert: aGoal solutions",						"\t\tequals: { [ 3 even ] unaryRBNode }",						"\t\tmodulo: #asOrderedCollection.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         (rewritten asRBNode unifyo value:",						"\t          (RBMessageNode receiver: a asRBNode selector: #even))",						"         , ((RBLiteralValueNode value: 3) unifyo value: a asRBNode) ] ]",						"\t         asGoalWithUnaryASTof: [ :a :b | a + b ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"self",						"\tassert: aGoal solutions",						"\tequals: { [ 3 even ] unaryRBNode }",						"\tmodulo: #asOrderedCollection.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3895028,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_56" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_56",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :x :y :a :b :c | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | y cons: o = (x isAtom = false) ]",						"\t\t\t\t         do: [ :o :r | theory carConsº value: r value: o ].",						"",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         y cons:",						"\t\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t\t         = (x isAtom = o) ]",						"\t\t\t\t         do: [ :o :r | theory isAtomConsº value: r value: o ].",						"",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         y cons:",						"\t\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t\t         = (x isAtom = (o isAtom cons: (a cons: b) = c) isAtom) ]",						"\t\t\t\t         do: [ :o :r | theory cdrConsº value: o value: r ].",						"",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         y cons:",						"\t\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t\t         = (x isAtom = (b isAtom cons: o) isAtom) ]",						"\t\t\t\t         do: [ :o :r | theory equalSwapº value: o value: r ] ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: (Dictionary new",						"\t\t\t\t          at: #x put: x asRBNode;",						"\t\t\t\t          at: #y put: y asRBNode;",						"\t\t\t\t          at: #a put: a asRBNode;",						"\t\t\t\t          at: #b put: b asRBNode;",						"\t\t\t\t          at: #c put: c asRBNode;",						"\t\t\t\t          yourself) ] ]",						"\t\t         asGoalWithUnaryASTof: [ :x :y :a :b :c | ",						"\t\t\t         y cons: (x cdr cons: y car) car = (x isAtom = false) ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := self expectedRBNode_chapter_01_frame_56.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node formattedCode",						"\t\tequals:",						"\t\t\t'•₀ cons: ((•₁ cdr cons: •₀ car) car cons: (#oats cons: nil)) car",						"\t= (•₁ isAtom = (•₂ isAtom cons: •₃ = (•₄ cons: •₂)) isAtom)'.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :x :y :a :b :c | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | y cons: o = (x isAtom = false) ]",						"\t\t\t         do: [ :o :r | theory carConsº value: r value: o ].",						"",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         y cons:",						"\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t         = (x isAtom = o) ]",						"\t\t\t         do: [ :o :r | theory isAtomConsº value: r value: o ].",						"",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         y cons:",						"\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t         = (x isAtom = (o isAtom cons: (a cons: b) = c) isAtom) ]",						"\t\t\t         do: [ :o :r | theory cdrConsº value: o value: r ].",						"",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         y cons:",						"\t\t\t\t\t         ((x cdr cons: y car) car cons: (#oats cons: nil)) car",						"\t\t\t\t\t         = (x isAtom = (b isAtom cons: o) isAtom) ]",						"\t\t\t         do: [ :o :r | theory equalSwapº value: o value: r ] ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: (Dictionary new",						"\t\t\t          at: #x put: x asRBNode;",						"\t\t\t          at: #y put: y asRBNode;",						"\t\t\t          at: #a put: a asRBNode;",						"\t\t\t          at: #b put: b asRBNode;",						"\t\t\t          at: #c put: c asRBNode;",						"\t\t\t          yourself) ] ]",						"\t         asGoalWithUnaryASTof: [ :x :y :a :b :c | ",						"\t\t         y cons: (x cdr cons: y car) car = (x isAtom = false) ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := self expectedRBNode_chapter_01_frame_56.",						"",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node formattedCode",						"\tequals:",						"\t\t'•₀ cons: ((•₁ cdr cons: •₀ car) car cons: (#oats cons: nil)) car",						"\t= (•₁ isAtom = (•₂ isAtom cons: •₃ = (•₄ cons: •₂)) isAtom)'.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157970,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_21" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_21",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | #flapjack = o ] do: theory isAtomConsº;",						"\t\t\t\t         focus: [ :o | o ] do: self flapjackNilFalseº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :b | ",						"\t\t         #flapjack = (a cons: b) isAtom ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { false asLiteralRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | #flapjack = o ] do: theory isAtomConsº;",						"\t\t\t         focus: [ :o | o ] do: self flapjackNilFalseº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :a :b | ",						"\t         #flapjack = (a cons: b) isAtom ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"self assert: aGoal solutions asArray equals: { false asLiteralRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894806,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_06" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_06",						"",						"\t\"(car (cons 'ham '(eggs)))\"",						"",						"\tself assert: (#ham cons: (#eggs cons: nil)) car equals: #ham"					],					"body" : [						"self assert: (#ham cons: (#eggs cons: nil)) car equals: #ham"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"(car (cons 'ham '(eggs)))"					],					"hash" : 3631370,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_32" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_32",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | o isAtom ] do: theory cdrConsº;",						"\t\t\t\t         focus: [ :o | o ] do: theory isAtomNilº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :p :q | ",						"\t\t         ((p cons: q) car cons: nil) cdr isAtom ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tself assert: aGoal solutions asArray equals: { true asLiteralRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | o isAtom ] do: theory cdrConsº;",						"\t\t\t         focus: [ :o | o ] do: theory isAtomNilº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :p :q | ",						"\t         ((p cons: q) car cons: nil) cdr isAtom ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"self assert: aGoal solutions asArray equals: { true asLiteralRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894805,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_44" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_44",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t         (o cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\t\t         do: theory equalSameº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t\t\t         ((x cons: y) = (x cons: y) cons:",						"\t\t\t\t          (#and cons: (#crumpets cons: nil))) car ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals:",						"\t\t{ [ (true cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\tunaryRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t         (o cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\t         do: theory equalSameº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t\t         ((x cons: y) = (x cons: y) cons:",						"\t\t\t          (#and cons: (#crumpets cons: nil))) car ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"self",						"\tassert: aGoal solutions asArray",						"\tequals:",						"\t{ [ (true cons: (#and cons: (#crumpets cons: nil))) car ] unaryRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3895004,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_55" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_55",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | b cons: o = (a isAtom = false) ]",						"\t\t\t\t         do: [ :o :r | theory carConsº value: r value: o ] ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: (Dictionary new",						"\t\t\t\t          at: #a put: a asRBNode;",						"\t\t\t\t          at: #b put: b asRBNode;",						"\t\t\t\t          yourself) ] ]",						"\t\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t\t         y cons: (x cdr cons: y car) car = (x isAtom = false) ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := self expectedRBNode_chapter_01_frame_55.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node formattedCode equals: '•₀ cons:",						"\t((•₁ cdr cons: •₀ car) car cons: •₂) car = (•₁ isAtom = false)'.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | b cons: o = (a isAtom = false) ]",						"\t\t\t         do: [ :o :r | theory carConsº value: r value: o ] ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: (Dictionary new",						"\t\t\t          at: #a put: a asRBNode;",						"\t\t\t          at: #b put: b asRBNode;",						"\t\t\t          yourself) ] ]",						"\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t         y cons: (x cdr cons: y car) car = (x isAtom = false) ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := self expectedRBNode_chapter_01_frame_55.",						"",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node formattedCode equals: '•₀ cons:",						"\t((•₁ cdr cons: •₀ car) car cons: •₂) car = (•₁ isAtom = false)'.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157970,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_49" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_49",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t         rewrite focus: [ :o | o ] do: theory equalSwapº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t\t         (x cons: y) = (#bagels cons: (#and cons: (#lox cons: nil))) ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := RBMessageNode",						"\t\t        receiver:",						"\t\t        [ (#bagels cons: (#and cons: (#lox cons: nil))) ]",						"\t\t\t        unaryRBNode",						"\t\t        selector: #=",						"\t\t        arguments: { (RBMessageNode",						"\t\t\t\t         receiver: 0 asReifiedVar asRBNode",						"\t\t\t\t         selector: #cons:",						"\t\t\t\t         arguments: { 1 asReifiedVar asRBNode }) }.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node formattedCode",						"\t\tequals:",						"\t\t\t'(#bagels cons: (#and cons: (#lox cons: nil))) = (•₀ cons: •₁)'.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t         rewrite focus: [ :o | o ] do: theory equalSwapº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t         (x cons: y) = (#bagels cons: (#and cons: (#lox cons: nil))) ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := RBMessageNode",						"\t        receiver:",						"\t        [ (#bagels cons: (#and cons: (#lox cons: nil))) ] unaryRBNode",						"\t        selector: #=",						"\t        arguments: { (RBMessageNode",						"\t\t\t         receiver: 0 asReifiedVar asRBNode",						"\t\t\t         selector: #cons:",						"\t\t\t         arguments: { 1 asReifiedVar asRBNode }) }.",						"",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node formattedCode",						"\tequals:",						"\t\t'(#bagels cons: (#and cons: (#lox cons: nil))) = (•₀ cons: •₁)'.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157738,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_46" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_46",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :rewrite | ",						"\t\t\t         rewrite",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t         (o cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\t\t         do: theory equalSameº.",						"\t\t\t         rewrite focus: [ :o | o ] do: theory carConsº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t\t\t         ((x cons: y) = (x cons: y) cons:",						"\t\t\t\t          (#and cons: (#crumpets cons: nil))) car ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tself assert: aGoal solutions asArray equals: { true asLiteralRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :rewrite | ",						"\t\t         rewrite",						"\t\t\t         focus: [ :o | ",						"\t\t\t         (o cons: (#and cons: (#crumpets cons: nil))) car ]",						"\t\t\t         do: theory equalSameº.",						"\t\t         rewrite focus: [ :o | o ] do: theory carConsº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :x :y | ",						"\t\t         ((x cons: y) = (x cons: y) cons:",						"\t\t\t          (#and cons: (#crumpets cons: nil))) car ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"self assert: aGoal solutions asArray equals: { true asLiteralRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894805,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_14" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_14",						"",						"\t\"(atom (cons 'ham '(eggs)))\"",						"",						"\tself assert: (#ham cons: (#eggs cons: nil)) isAtom equals: false"					],					"body" : [						"self assert: (#ham cons: (#eggs cons: nil)) isAtom equals: false"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"(atom (cons 'ham '(eggs)))"					],					"hash" : 3631416,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_16_backward" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_16_backward",						"",						"\t| aGoal node |",						"\taGoal := [ :ast | ",						"\t         [ :a | ",						"\t         theory isAtomConsº value: ast value: false asLiteralRBNode ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a | a isAtom ]",						"\t\t         contextVariables: Dictionary empty.",						"",						"\tnode := [ :a :b | a cons: b ] ",						"\t\t        substituteVariablesUsingSequenceableCollection: { ",						"\t\t\t\t        0 asReifiedVar asRBNode.",						"\t\t\t\t        1 asReifiedVar asRBNode }.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node formattedCode equals: '•₀ cons: •₁'.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal node |",						"aGoal := [ :ast | ",						"         [ :a | ",						"         theory isAtomConsº value: ast value: false asLiteralRBNode ] ]",						"\t         asGoalWithUnaryASTof: [ :a | a isAtom ]",						"\t         contextVariables: Dictionary empty.",						"",						"node := [ :a :b | a cons: b ] ",						"\t        substituteVariablesUsingSequenceableCollection: { ",						"\t\t\t        0 asReifiedVar asRBNode.",						"\t\t\t        1 asReifiedVar asRBNode }.",						"",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node formattedCode equals: '•₀ cons: •₁'.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157259,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_28" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_28",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | (o cons: nil) cdr isAtom ]",						"\t\t\t\t         do: theory carConsº;",						"\t\t\t\t         focus: [ :o | o isAtom ] do: theory cdrConsº;",						"\t\t\t\t         focus: [ :o | o ] do: theory isAtomNilº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :p :q | ",						"\t\t         ((p cons: q) car cons: nil) cdr isAtom ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tself assert: aGoal solutions asArray equals: { true asLiteralRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | (o cons: nil) cdr isAtom ]",						"\t\t\t         do: theory carConsº;",						"\t\t\t         focus: [ :o | o isAtom ] do: theory cdrConsº;",						"\t\t\t         focus: [ :o | o ] do: theory isAtomNilº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :p :q | ",						"\t         ((p cons: q) car cons: nil) cdr isAtom ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"self assert: aGoal solutions asArray equals: { true asLiteralRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894805,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_16_byCompiledMethod",						"",						"\t| aGoal |",						"\taGoal := [ :rewrite | ",						"\t         [ :ast | self consº: ast isAtomº: rewrite asRBNode ]",						"\t\t         asGoalWithUnaryASTof: self class >> #consª:isAtomª:",						"\t\t         contextVariables: #(  ) ] asGoal.",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { false asLiteralRBNode }"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewrite | ",						"         [ :ast | self consº: ast isAtomº: rewrite asRBNode ]",						"\t         asGoalWithUnaryASTof: self class >> #consª:isAtomª:",						"\t         contextVariables: #(  ) ] asGoal.",						"self assert: aGoal solutions asArray equals: { false asLiteralRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894419,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_11" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_11",						"",						"\t\"(atom '())\"",						"",						"\tself assert: nil isAtom equals: true"					],					"body" : [						"self assert: nil isAtom equals: true"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"(atom '())"					],					"hash" : 3630997,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_46_variablesBindingByEqualSame" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_46_variablesBindingByEqualSame",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :car :cdr | ",						"\t         [ :r | ",						"\t         | g1 g2 |",						"\t         g1 := theory equalSameº value: ast value: r asRBNode.",						"\t         g2 := rewritten asRBNode unifyo value: (RBMessageNode",						"\t\t\t                receiver: car asRBNode",						"\t\t\t                selector: #cons:",						"\t\t\t                arguments: { cdr asRBNode }).",						"\t         g1 , g2 ] asGoal ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :d | ",						"\t\t         (#and cons: d) = (a cons: nil) ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { [ #and cons: nil ] unaryRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :car :cdr | ",						"         [ :r | ",						"         | g1 g2 |",						"         g1 := theory equalSameº value: ast value: r asRBNode.",						"         g2 := rewritten asRBNode unifyo value: (RBMessageNode",						"\t\t                receiver: car asRBNode",						"\t\t                selector: #cons:",						"\t\t                arguments: { cdr asRBNode }).",						"         g1 , g2 ] asGoal ] ]",						"\t         asGoalWithUnaryASTof: [ :a :d | ",						"\t         (#and cons: d) = (a cons: nil) ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"self",						"\tassert: aGoal solutions asArray",						"\tequals: { [ #and cons: nil ] unaryRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3895004,					"argumentNames" : [ ]				}			}		},		"test_chapter_01_OldGamesNewRules_frame_19" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_01_OldGamesNewRules_frame_19",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | #flapjack = o ]",						"\t\t\t\t         do: theory isAtomConsº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :b | ",						"\t\t         #flapjack = (a cons: b) isAtom ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"\tself",						"\t\tassert: aGoal solutions asArray",						"\t\tequals: { [ #flapjack = false ] unaryRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover focus: [ :o | #flapjack = o ] do: theory isAtomConsº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :a :b | ",						"\t         #flapjack = (a cons: b) isAtom ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"self",						"\tassert: aGoal solutions asArray",						"\tequals: { [ #flapjack = false ] unaryRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3895004,					"argumentNames" : [ ]				}			}		}	}}