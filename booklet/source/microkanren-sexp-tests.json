{	"classes" : {		"MKSexpTest" : {			"hash" : 2846208,			"definition" : "Srfi41AbstractTest subclass: #MKSexpTest\r\tuses: TIceImagesExporting\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-Tests'",			"comment" : [				"This class contains tests"			],			"category" : "MicroKanren-Tests"		},		"CombinatoricsTheoryTest" : {			"hash" : 2837760,			"definition" : "Srfi41AbstractTest subclass: #CombinatoricsTheoryTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-Tests'",			"comment" : [				"This class contains tests"			],			"category" : "MicroKanren-Tests"		}	},	"messages" : {		"testDycko" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportSexpTestsForDoc",				"BaselineOfMicroKanren>>#exportForDocScript"			],			"implementors" : {				"MKSexpTest" : {					"sourceCode" : [						"testDycko",						"",						"\t| g |",						"\tg := [ :alpha | MKPredicateSexpDycko value: alpha ] asGoal.",						"\tself",						"\t\texport: (g asLogicComputationTreeLimitedTo: 20)",						"\t\tpathSuffix: 'sexp-dycko'",						"\t\tselector: #gtInspectorTreeUsingCanvas:"					],					"body" : [						"| g |",						"g := [ :alpha | MKPredicateSexpDycko value: alpha ] asGoal.",						"self",						"\texport: (g asLogicComputationTreeLimitedTo: 20)",						"\tpathSuffix: 'sexp-dycko'",						"\tselector: #gtInspectorTreeUsingCanvas:"					],					"category" : "tests",					"comment" : [ ],					"hash" : 3903450,					"argumentNames" : [ ]				},				"CombinatoricsTheoryTest" : {					"sourceCode" : [						"testDycko",						"",						"\t| g combTheory |",						"\tcombTheory := CombinatoricsTheory new.",						"\tg := [ :alpha | combTheory dycko value: alpha ] asGoal.",						"\tself",						"\t\tassert: (g solutions next: 20)",						"\t\tequals:",						"\t\t\t({ nil. '()'. '(())'. '()()'. '(()())'. '(())()'. '()(())'. '(()()())'.",						"\t\t\t '((()))'. '(())(())'. '()()()'. '(()()()())'. '((())())'.",						"\t\t\t '(()())()'. '(())()()'. '()(()())'. '(()()()()())'. '((())()())'.",						"\t\t\t '(()()())()'. '((()))()' } collect: #asCons)",						"\t\tmodulo: #asOrderedCollection.",						"\tg := [ :alpha | combTheory dycko value: '(()(())()(' asCons ] asGoal.",						"\t\"an invalid Dyck path\"",						"\tself assert: g solutions isEmpty"					],					"body" : [						"| g combTheory |",						"combTheory := CombinatoricsTheory new.",						"g := [ :alpha | combTheory dycko value: alpha ] asGoal.",						"self",						"\tassert: (g solutions next: 20)",						"\tequals:",						"\t\t({ nil. '()'. '(())'. '()()'. '(()())'. '(())()'. '()(())'. '(()()())'.",						"\t\t '((()))'. '(())(())'. '()()()'. '(()()()())'. '((())())'. '(()())()'.",						"\t\t '(())()()'. '()(()())'. '(()()()()())'. '((())()())'. '(()()())()'.",						"\t\t '((()))()' } collect: #asCons)",						"\tmodulo: #asOrderedCollection.",						"g := [ :alpha | combTheory dycko value: '(()(())()(' asCons ] asGoal.",						"\"an invalid Dyck path\"",						"self assert: g solutions isEmpty"					],					"category" : "tests",					"comment" : [ ],					"hash" : 4290555,					"argumentNames" : [ ]				}			}		},		"testAppendoForward" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportSexpTestsForDoc",				"BaselineOfMicroKanren>>#exportForDocScript"			],			"implementors" : {				"MKSexpTest" : {					"sourceCode" : [						"testAppendoForward",						"",						"\t| g |",						"\tg := [ :l | ",						"\t     SexpTheory new appendo",						"\t\t     value: #( #a #b #c ) asCons",						"\t\t     value: #( #d #e ) asCons",						"\t\t     value: l ] asGoal.",						"\tself",						"\t\tassert: g solutions",						"\t\tequals: #( a b c d e ) asCons",						"\t\tmodulo: #asOrderedCollection.",						"",						"\t\"Export it.\"",						"\tself",						"\t\texport: (g asLogicComputationTreeLimitedTo: -1)",						"\t\tpathSuffix: 'sexp-appendo-forward'",						"\t\tselector: #gtInspectorTreeUsingCanvas:"					],					"body" : [						"| g |",						"g := [ :l | ",						"     SexpTheory new appendo",						"\t     value: #( #a #b #c ) asCons",						"\t     value: #( #d #e ) asCons",						"\t     value: l ] asGoal.",						"self",						"\tassert: g solutions",						"\tequals: #( a b c d e ) asCons",						"\tmodulo: #asOrderedCollection.",						"",						"\"Export it.\"",						"self",						"\texport: (g asLogicComputationTreeLimitedTo: -1)",						"\tpathSuffix: 'sexp-appendo-forward'",						"\tselector: #gtInspectorTreeUsingCanvas:"					],					"category" : "tests",					"comment" : [ ],					"hash" : 3904579,					"argumentNames" : [ ]				}			}		},		"testACORN" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportSexpTestsForDoc",				"BaselineOfMicroKanren>>#exportForDocScript"			],			"implementors" : {				"MKSexpTest" : {					"sourceCode" : [						"testACORN",						"",						"\t| g |",						"\tg := [ :r | MKPredicateSexpCaro value: 'acorn' asCons value: r ]",						"\t\t     asGoal.",						"\tself assert: g solutions equals: { $a } modulo: #asOrderedCollection.",						"",						"\t\"Export it.\"",						"\tself",						"\t\texport: (g asLogicComputationTreeLimitedTo: -1)",						"\t\tpathSuffix: 'sexp-acorn'",						"\t\tselector: #gtInspectorTreeUsingCanvas:"					],					"body" : [						"| g |",						"g := [ :r | MKPredicateSexpCaro value: 'acorn' asCons value: r ]",						"\t     asGoal.",						"self assert: g solutions equals: { $a } modulo: #asOrderedCollection.",						"",						"\"Export it.\"",						"self",						"\texport: (g asLogicComputationTreeLimitedTo: -1)",						"\tpathSuffix: 'sexp-acorn'",						"\tselector: #gtInspectorTreeUsingCanvas:"					],					"category" : "tests",					"comment" : [ ],					"hash" : 3904770,					"argumentNames" : [ ]				}			}		},		"testAppendoBackward" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportSexpTestsForDoc",				"BaselineOfMicroKanren>>#exportForDocScript"			],			"implementors" : {				"MKSexpTest" : {					"sourceCode" : [						"testAppendoBackward",						"",						"\t| g |",						"\tg := [ :l :r | ",						"\t     SexpTheory new appendo",						"\t\t     value: l",						"\t\t     value: r",						"\t\t     value: #( a b c d e ) asCons ] asGoal.",						"\tself",						"\t\tassert: g solutions",						"\t\tequals: ({ ",						"\t\t\t\t #( nil #( #a #b #c #d #e ) ).",						"\t\t\t\t #( #( #a ) #( #b #c #d #e ) ).",						"\t\t\t\t #( #( #a #b ) #( #c #d #e ) ).",						"\t\t\t\t #( #( #a #b #c ) #( #d #e ) ).",						"\t\t\t\t #( #( #a #b #c #d ) #( #e ) ).",						"\t\t\t\t #( #( #a #b #c #d #e ) nil ) } collect: [ :each | ",						"\t\t\t\t each collect: #asCons ])",						"\t\tmodulo: #asOrderedCollection.",						"",						"\t\"Export it.\"",						"\tself",						"\t\texport: (g asLogicComputationTreeLimitedTo: -1)",						"\t\tpathSuffix: 'sexp-appendo-backward'",						"\t\tselector: #gtInspectorTreeUsingCanvas:"					],					"body" : [						"| g |",						"g := [ :l :r | ",						"     SexpTheory new appendo",						"\t     value: l",						"\t     value: r",						"\t     value: #( a b c d e ) asCons ] asGoal.",						"self",						"\tassert: g solutions",						"\tequals: ({ ",						"\t\t\t #( nil #( #a #b #c #d #e ) ).",						"\t\t\t #( #( #a ) #( #b #c #d #e ) ).",						"\t\t\t #( #( #a #b ) #( #c #d #e ) ).",						"\t\t\t #( #( #a #b #c ) #( #d #e ) ).",						"\t\t\t #( #( #a #b #c #d ) #( #e ) ).",						"\t\t\t #( #( #a #b #c #d #e ) nil ) } collect: [ :each | ",						"\t\t\t each collect: #asCons ])",						"\tmodulo: #asOrderedCollection.",						"",						"\"Export it.\"",						"self",						"\texport: (g asLogicComputationTreeLimitedTo: -1)",						"\tpathSuffix: 'sexp-appendo-backward'",						"\tselector: #gtInspectorTreeUsingCanvas:"					],					"category" : "tests",					"comment" : [ ],					"hash" : 3905652,					"argumentNames" : [ ]				}			}		}	}}