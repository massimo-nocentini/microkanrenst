{	"classes" : {		"TheLittleProverTest" : {			"hash" : 6866432,			"definition" : "GoalAbstractTest subclass: #TheLittleProverTest\r\tinstanceVariableNames: 'theory'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-Tests'",			"comment" : [				"A RBProgramNodeIdentityVisitorTest is a test class for testing the behavior of RBProgramNodeIdentityVisitor"			],			"category" : "MicroKanren-Tests"		}	},	"messages" : {		"test_chapter_02_EvenOlderGames_frame_15_parento" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_15_parento",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         theory parentº",						"\t\t         value: false asLiteralRBNode",						"\t\t         value: rewritten asRBNode ] asGoal.",						"",						"\tself",						"\t\tassert:",						"\t\t(aGoal solutions collect: [ :e | e formattedCode ]) readStream",						"\t\t\tupToEnd",						"\t\tequals: #( 'false car' 'false cdr' '[ false ]' 'false' 'false = •₀'",						"\t\t\t   '•₀ = false' 'false cons: •₀' '•₀ cons: false' 'false + •₀'",						"\t\t\t   '•₀ + false' 'false - •₀' '•₀ - false' 'false",						"\tifTrue: [ •₀ ]",						"\tifFalse: [ •₁ ]' '•₀",						"\tifTrue: [ false ]",						"\tifFalse: [ •₁ ]' '•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ false ]' ).",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         theory parentº",						"\t         value: false asLiteralRBNode",						"\t         value: rewritten asRBNode ] asGoal.",						"",						"self",						"\tassert:",						"\t(aGoal solutions collect: [ :e | e formattedCode ]) readStream",						"\t\tupToEnd",						"\tequals: #( 'false car' 'false cdr' '[ false ]' 'false' 'false = •₀'",						"\t\t   '•₀ = false' 'false cons: •₀' '•₀ cons: false' 'false + •₀'",						"\t\t   '•₀ + false' 'false - •₀' '•₀ - false' 'false",						"\tifTrue: [ •₀ ]",						"\tifFalse: [ •₁ ]' '•₀",						"\tifTrue: [ false ]",						"\tifFalse: [ •₁ ]' '•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ false ]' ).",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 7924569,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_57_premise" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_57_premise",						"",						"\t| aGoal n a |",						"\taGoal := [ :v :w | ",						"\t         a := RBMessageNode",						"\t\t              receiver: (RBLiteralValueNode value: #ketchup)",						"\t\t              selector: #cons:",						"\t\t              arguments: { (RBMessageNode",						"\t\t\t\t               receiver: (RBMessageNode",						"\t\t\t\t\t\t                receiver:",						"\t\t\t\t\t\t                (RBMessageNode",						"\t\t\t\t\t\t\t                 receiver: v asRBNode",						"\t\t\t\t\t\t\t                 selector: #car)",						"\t\t\t\t\t\t                selector: #car)",						"\t\t\t\t               selector: #cons:",						"\t\t\t\t               arguments: { (RBMessageNode",						"\t\t\t\t\t\t                receiver:",						"\t\t\t\t\t\t                (RBMessageNode",						"\t\t\t\t\t\t\t                 receiver: v asRBNode",						"\t\t\t\t\t\t\t                 selector: #car)",						"\t\t\t\t\t\t                selector: #cdr) }) }.",						"\t         n := RBMessageNode",						"\t\t              receiver:",						"\t\t              (RBMessageNode receiver: w asRBNode selector: #car)",						"\t\t              selector: #cdr.",						"",						"\t         (theory unifyº value: n value: a)",						"\t         | (theory ancestorº value: n value: a) ] asGoal.",						"",						"\tself",						"\t\tassert: (aGoal solutions next: 40) readStream upToEnd asString",						"\t\tequals:",						"\t\t\t'an Array(an Array(•₀ •₀) an Array(RBMessageNode(•₀ car cdr) •₀) an Array(RBMessageNode(•₀ car cdr) •₀) an Array(RBMessageNode(•₀ car cdr car) •₀) an Array(RBMessageNode(•₀ car cdr cdr) •₀) an Array(RBMessageNode(•₀ car cdr car) •₀) an Array(RBMessageNode(•₀ car cdr cdr) •₀) an Array(RBBlockNode([ •₀ car cdr ]) •₀) an Array(RBSequenceNode(•₀ car cdr) •₀) an Array(RBBlockNode([ •₀ car cdr ]) •₀) an Array(RBSequenceNode(•₀ car cdr) •₀) an Array(RBMessageNode(•₀ car cdr car car) •₀) an Array(RBMessageNode(•₀ car cdr cdr car) •₀) an Array(RBMessageNode(•₀ car cdr car car) •₀) an Array(RBMessageNode(•₀ car cdr cdr car) •₀) an Array(RBMessageNode(•₀ car cdr = •₁) •₀) an Array(RBMessageNode(•₀ = •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr cons: •₁) •₀) an Array(RBMessageNode(•₀ cons: •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr + •₁) •₀) an Array(RBMessageNode(•₀ + •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr - •₁) •₀) an Array(RBMessageNode(•₀ - •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ ]) •₀) an Array(RBMessageNode(•₀",						"\tifTrue: [ •₁ car cdr ]",						"\tifFalse: [ •₂ ]) •₁) an Array(RBMessageNode(•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ car cdr ]) •₂) an Array(RBMessageNode(•₀ car cdr car cdr) •₀) an Array(RBMessageNode(•₀ car cdr cdr cdr) •₀) an Array(RBMessageNode(•₀ car cdr = •₁) •₀) an Array(RBMessageNode(•₀ = •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr cons: •₁) •₀) an Array(RBMessageNode(•₀ cons: •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr + •₁) •₀) an Array(RBMessageNode(•₀ + •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr - •₁) •₀) an Array(RBMessageNode(•₀ - •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ ]) •₀) an Array(RBMessageNode(•₀",						"\tifTrue: [ •₁ car cdr ]",						"\tifFalse: [ •₂ ]) •₁) an Array(RBMessageNode(•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ car cdr ]) •₂) an Array(RBMessageNode(•₀ car cdr car cdr) •₀))'.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: 40"					],					"body" : [						"| aGoal n a |",						"aGoal := [ :v :w | ",						"         a := RBMessageNode",						"\t              receiver: (RBLiteralValueNode value: #ketchup)",						"\t              selector: #cons:",						"\t              arguments: { (RBMessageNode",						"\t\t\t               receiver: (RBMessageNode",						"\t\t\t\t\t                receiver:",						"\t\t\t\t\t                (RBMessageNode",						"\t\t\t\t\t\t                 receiver: v asRBNode",						"\t\t\t\t\t\t                 selector: #car)",						"\t\t\t\t\t                selector: #car)",						"\t\t\t               selector: #cons:",						"\t\t\t               arguments: { (RBMessageNode",						"\t\t\t\t\t                receiver:",						"\t\t\t\t\t                (RBMessageNode",						"\t\t\t\t\t\t                 receiver: v asRBNode",						"\t\t\t\t\t\t                 selector: #car)",						"\t\t\t\t\t                selector: #cdr) }) }.",						"         n := RBMessageNode",						"\t              receiver:",						"\t              (RBMessageNode receiver: w asRBNode selector: #car)",						"\t              selector: #cdr.",						"",						"         (theory unifyº value: n value: a)",						"         | (theory ancestorº value: n value: a) ] asGoal.",						"",						"self",						"\tassert: (aGoal solutions next: 40) readStream upToEnd asString",						"\tequals:",						"\t\t'an Array(an Array(•₀ •₀) an Array(RBMessageNode(•₀ car cdr) •₀) an Array(RBMessageNode(•₀ car cdr) •₀) an Array(RBMessageNode(•₀ car cdr car) •₀) an Array(RBMessageNode(•₀ car cdr cdr) •₀) an Array(RBMessageNode(•₀ car cdr car) •₀) an Array(RBMessageNode(•₀ car cdr cdr) •₀) an Array(RBBlockNode([ •₀ car cdr ]) •₀) an Array(RBSequenceNode(•₀ car cdr) •₀) an Array(RBBlockNode([ •₀ car cdr ]) •₀) an Array(RBSequenceNode(•₀ car cdr) •₀) an Array(RBMessageNode(•₀ car cdr car car) •₀) an Array(RBMessageNode(•₀ car cdr cdr car) •₀) an Array(RBMessageNode(•₀ car cdr car car) •₀) an Array(RBMessageNode(•₀ car cdr cdr car) •₀) an Array(RBMessageNode(•₀ car cdr = •₁) •₀) an Array(RBMessageNode(•₀ = •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr cons: •₁) •₀) an Array(RBMessageNode(•₀ cons: •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr + •₁) •₀) an Array(RBMessageNode(•₀ + •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr - •₁) •₀) an Array(RBMessageNode(•₀ - •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ ]) •₀) an Array(RBMessageNode(•₀",						"\tifTrue: [ •₁ car cdr ]",						"\tifFalse: [ •₂ ]) •₁) an Array(RBMessageNode(•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ car cdr ]) •₂) an Array(RBMessageNode(•₀ car cdr car cdr) •₀) an Array(RBMessageNode(•₀ car cdr cdr cdr) •₀) an Array(RBMessageNode(•₀ car cdr = •₁) •₀) an Array(RBMessageNode(•₀ = •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr cons: •₁) •₀) an Array(RBMessageNode(•₀ cons: •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr + •₁) •₀) an Array(RBMessageNode(•₀ + •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr - •₁) •₀) an Array(RBMessageNode(•₀ - •₁ car cdr) •₁) an Array(RBMessageNode(•₀ car cdr",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ ]) •₀) an Array(RBMessageNode(•₀",						"\tifTrue: [ •₁ car cdr ]",						"\tifFalse: [ •₂ ]) •₁) an Array(RBMessageNode(•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ car cdr ]) •₂) an Array(RBMessageNode(•₀ car cdr car cdr) •₀))'.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: 40"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8187138,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_15_ancestoro" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_15_ancestoro",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         theory ancestorº",						"\t\t         value: false asLiteralRBNode",						"\t\t         value: rewritten asRBNode ] asGoal.",						"",						"\tself",						"\t\tassert:",						"\t\t\t((aGoal solutions collect: [ :e | e formattedCode ]) next: 25)",						"\t\t\t\treadStream upToEnd",						"\t\tequals:",						"\t\t\t#( 'false car' 'false cdr' '[ false ]' 'false' 'false car car'",						"\t\t\t   'false cdr car' 'false = •₀' '•₀ = false' 'false cons: •₀'",						"\t\t\t   '•₀ cons: false' 'false + •₀' '•₀ + false' 'false - •₀'",						"\t\t\t   '•₀ - false' 'false",						"\tifTrue: [ •₀ ]",						"\tifFalse: [ •₁ ]' '•₀",						"\tifTrue: [ false ]",						"\tifFalse: [ •₁ ]' '•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ false ]' 'false car cdr' 'false cdr cdr' '[ false ] car'",						"\t\t\t   'false car' 'false car car car' 'false cdr car car'",						"\t\t\t   '[ false car ]' '[ false cdr ]' ).",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: 25"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         theory ancestorº",						"\t         value: false asLiteralRBNode",						"\t         value: rewritten asRBNode ] asGoal.",						"",						"self",						"\tassert:",						"\t\t((aGoal solutions collect: [ :e | e formattedCode ]) next: 25)",						"\t\t\treadStream upToEnd",						"\tequals:",						"\t\t#( 'false car' 'false cdr' '[ false ]' 'false' 'false car car'",						"\t\t   'false cdr car' 'false = •₀' '•₀ = false' 'false cons: •₀'",						"\t\t   '•₀ cons: false' 'false + •₀' '•₀ + false' 'false - •₀'",						"\t\t   '•₀ - false' 'false",						"\tifTrue: [ •₀ ]",						"\tifFalse: [ •₁ ]' '•₀",						"\tifTrue: [ false ]",						"\tifFalse: [ •₁ ]' '•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ false ]' 'false car cdr' 'false cdr cdr' '[ false ] car'",						"\t\t   'false car' 'false car car car' 'false cdr car car'",						"\t\t   '[ false car ]' '[ false cdr ]' ).",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: 25"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 7924780,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_43" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_43",						"",						"\t| aGoal node |",						"\tself skip.",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         #gyre cons:",						"\t\t\t\t\t\t         ((#callooh cons: (#callay cons: nil)) isUffish",						"\t\t\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t\t\t          #gimble cons:",						"\t\t\t\t\t\t\t\t\t          ((#callooh cons: (#callay cons: nil)) isBrillig",						"\t\t\t\t\t\t\t\t\t\t           ifTrue: [ #borogove cons: (#outgrabe cons: nil) ]",						"\t\t\t\t\t\t\t\t\t\t           ifFalse: [ o cons: (#wabe cons: nil) ]) ]",						"\t\t\t\t\t\t\t          ifFalse: [ ",						"\t\t\t\t\t\t\t\t          (#callooh cons: (#callay cons: nil)) frabjous cons:",						"\t\t\t\t\t\t\t\t\t          (#vorpal cons: nil) ]) ]",						"\t\t\t\t         premise: [ :o | #gyre cons: o ]",						"\t\t\t\t         do: [ :o :p :r | ",						"\t\t\t\t\t         theory jabberwockyº value: r value: p value: o",						"\t\t\t\t\t         \" , [ :aState | self halt ] inspectº\" ] ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ ",						"\t\t\t         #gyre cons:",						"\t\t\t\t         ((#callooh cons: (#callay cons: nil)) isUffish",						"\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t          #gimble cons:",						"\t\t\t\t\t\t\t          ((#callooh cons: (#callay cons: nil)) isBrillig",						"\t\t\t\t\t\t\t\t           ifTrue: [ #borogove cons: (#outgrabe cons: nil) ]",						"\t\t\t\t\t\t\t\t           ifFalse: [ #bandersnatch cons: (#wabe cons: nil) ]) ]",						"\t\t\t\t\t          ifFalse: [ ",						"\t\t\t\t\t\t          (#callooh cons: (#callay cons: nil)) frabjous cons:",						"\t\t\t\t\t\t\t          (#vorpal cons: nil) ]) ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := self expectedRBNode_chapter_02_frame_15.",						"",						"\tself",						"\t\tassert: (aGoal solutions next: 1) readStream upToEnd",						"\t\tequals: { node };",						"\t\tassert: node formattedCode equals: '(•₀ = true",						"\t ifTrue: [ true ]",						"\t ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₁ ]'"					],					"body" : [						"| aGoal node |",						"self skip.",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         #gyre cons:",						"\t\t\t\t\t         ((#callooh cons: (#callay cons: nil)) isUffish",						"\t\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t\t          #gimble cons:",						"\t\t\t\t\t\t\t\t          ((#callooh cons: (#callay cons: nil)) isBrillig",						"\t\t\t\t\t\t\t\t\t           ifTrue: [ #borogove cons: (#outgrabe cons: nil) ]",						"\t\t\t\t\t\t\t\t\t           ifFalse: [ o cons: (#wabe cons: nil) ]) ]",						"\t\t\t\t\t\t          ifFalse: [ ",						"\t\t\t\t\t\t\t          (#callooh cons: (#callay cons: nil)) frabjous cons:",						"\t\t\t\t\t\t\t\t          (#vorpal cons: nil) ]) ]",						"\t\t\t         premise: [ :o | #gyre cons: o ]",						"\t\t\t         do: [ :o :p :r | ",						"\t\t\t\t         theory jabberwockyº value: r value: p value: o",						"\t\t\t\t         \" , [ :aState | self halt ] inspectº\" ] ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ ",						"\t\t         #gyre cons: ((#callooh cons: (#callay cons: nil)) isUffish",						"\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t          #gimble cons:",						"\t\t\t\t\t\t          ((#callooh cons: (#callay cons: nil)) isBrillig",						"\t\t\t\t\t\t\t           ifTrue: [ #borogove cons: (#outgrabe cons: nil) ]",						"\t\t\t\t\t\t\t           ifFalse: [ #bandersnatch cons: (#wabe cons: nil) ]) ]",						"\t\t\t\t          ifFalse: [ ",						"\t\t\t\t\t          (#callooh cons: (#callay cons: nil)) frabjous cons:",						"\t\t\t\t\t\t          (#vorpal cons: nil) ]) ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := self expectedRBNode_chapter_02_frame_15.",						"",						"self",						"\tassert: (aGoal solutions next: 1) readStream upToEnd",						"\tequals: { node };",						"\tassert: node formattedCode equals: '(•₀ = true",						"\t ifTrue: [ true ]",						"\t ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₁ ]'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8188135,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_05" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_05",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :c | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t         prover focus: [ :o | o ] do: theory ifSameº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :c | ",						"\t\t\t         a",						"\t\t\t\t         ifTrue: [ 3 ]",						"\t\t\t\t         ifFalse: [ c ] ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tself",						"\t\tassert: aGoal solutions readStream upToEnd",						"\t\tequals: { 3 asLiteralRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :c | ",						"         ast",						"\t         acl: [ :prover | ",						"\t         prover focus: [ :o | o ] do: theory ifSameº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :a :c | ",						"\t\t         a",						"\t\t\t         ifTrue: [ 3 ]",						"\t\t\t         ifFalse: [ c ] ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"self",						"\tassert: aGoal solutions readStream upToEnd",						"\tequals: { 3 asLiteralRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 7924636,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_57" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_57",						"",						"\t| aGoal |",						"\tself skip.",						"",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         a car isAtom",						"\t\t\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t\t\t         a car = a cdr",						"\t\t\t\t\t\t\t\t         ifTrue: [ #hominy ]",						"\t\t\t\t\t\t\t\t         ifFalse: [ #grits ] ]",						"\t\t\t\t\t\t         ifFalse: [ ",						"\t\t\t\t\t\t\t         a car cdr = (#hash cons: (#browns cons: nil))",						"\t\t\t\t\t\t\t\t         ifTrue: [ #ketchup cons: o ]",						"\t\t\t\t\t\t\t\t         ifFalse: [ #mustard cons: a car ] ] ]",						"\t\t\t\t         premise: [ :o | o ]",						"\t\t\t\t         do: [ :o :p :r | ",						"\t\t\t\t         theory consCarCdrº value: r value: p value: o ].",						"",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         a car isAtom",						"\t\t\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t\t\t         a car = a cdr",						"\t\t\t\t\t\t\t\t         ifTrue: [ #hominy ]",						"\t\t\t\t\t\t\t\t         ifFalse: [ #grits ] ]",						"\t\t\t\t\t\t         ifFalse: [ ",						"\t\t\t\t\t\t\t         a car cdr = (#hash cons: (#browns cons: nil))",						"\t\t\t\t\t\t\t\t         ifTrue: [ #ketchup cons: (a car car cons: o) ]",						"\t\t\t\t\t\t\t\t         ifFalse: [ #mustard cons: a car ] ] ]",						"\t\t\t\t         premise: [ :o | ",						"\t\t\t\t\t         a car isAtom",						"\t\t\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t\t\t         a car = a cdr",						"\t\t\t\t\t\t\t\t         ifTrue: [ #hominy ]",						"\t\t\t\t\t\t\t\t         ifFalse: [ #grits ] ]",						"\t\t\t\t\t\t         ifFalse: [ o ] ]",						"\t\t\t\t         do: theory equalIfº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: (Dictionary new",						"\t\t\t\t          at: #a put: a asRBNode;",						"\t\t\t\t          yourself) ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a | ",						"\t\t\t         a car isAtom",						"\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t         a car = a cdr",						"\t\t\t\t\t\t         ifTrue: [ #hominy ]",						"\t\t\t\t\t\t         ifFalse: [ #grits ] ]",						"\t\t\t\t         ifFalse: [ ",						"\t\t\t\t\t         a car cdr = (#hash cons: (#browns cons: nil))",						"\t\t\t\t\t\t         ifTrue: [ #ketchup cons: a car ]",						"\t\t\t\t\t\t         ifFalse: [ #mustard cons: a car ] ] ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tself",						"\t\tassert: (aGoal solutions next: 1) readStream upToEnd",						"\t\tequals: { [ :a | ",						"\t\t\ta car isAtom",						"\t\t\t\tifTrue: [ ",						"\t\t\t\t\ta car = a cdr",						"\t\t\t\t\t\tifTrue: [ #hominy ]",						"\t\t\t\t\t\tifFalse: [ #grits ] ]",						"\t\t\t\tifFalse: [ ",						"\t\t\t\t\ta car cdr = (#hash cons: (#browns cons: nil))",						"\t\t\t\t\t\tifTrue: [ ",						"\t\t\t\t\t\t#ketchup cons:",						"\t\t\t\t\t\t\t(a car car cons: (#hash cons: (#browns cons: nil))) ]",						"\t\t\t\t\t\tifFalse: [ #mustard cons: a car ] ] ] unaryRBNode }"					],					"body" : [						"| aGoal |",						"self skip.",						"",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         a car isAtom",						"\t\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t\t         a car = a cdr",						"\t\t\t\t\t\t\t         ifTrue: [ #hominy ]",						"\t\t\t\t\t\t\t         ifFalse: [ #grits ] ]",						"\t\t\t\t\t         ifFalse: [ ",						"\t\t\t\t\t\t         a car cdr = (#hash cons: (#browns cons: nil))",						"\t\t\t\t\t\t\t         ifTrue: [ #ketchup cons: o ]",						"\t\t\t\t\t\t\t         ifFalse: [ #mustard cons: a car ] ] ]",						"\t\t\t         premise: [ :o | o ]",						"\t\t\t         do: [ :o :p :r | ",						"\t\t\t         theory consCarCdrº value: r value: p value: o ].",						"",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         a car isAtom",						"\t\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t\t         a car = a cdr",						"\t\t\t\t\t\t\t         ifTrue: [ #hominy ]",						"\t\t\t\t\t\t\t         ifFalse: [ #grits ] ]",						"\t\t\t\t\t         ifFalse: [ ",						"\t\t\t\t\t\t         a car cdr = (#hash cons: (#browns cons: nil))",						"\t\t\t\t\t\t\t         ifTrue: [ #ketchup cons: (a car car cons: o) ]",						"\t\t\t\t\t\t\t         ifFalse: [ #mustard cons: a car ] ] ]",						"\t\t\t         premise: [ :o | ",						"\t\t\t\t         a car isAtom",						"\t\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t\t         a car = a cdr",						"\t\t\t\t\t\t\t         ifTrue: [ #hominy ]",						"\t\t\t\t\t\t\t         ifFalse: [ #grits ] ]",						"\t\t\t\t\t         ifFalse: [ o ] ]",						"\t\t\t         do: theory equalIfº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: (Dictionary new",						"\t\t\t          at: #a put: a asRBNode;",						"\t\t\t          yourself) ] ]",						"\t         asGoalWithUnaryASTof: [ :a | ",						"\t\t         a car isAtom",						"\t\t\t         ifTrue: [ ",						"\t\t\t\t         a car = a cdr",						"\t\t\t\t\t         ifTrue: [ #hominy ]",						"\t\t\t\t\t         ifFalse: [ #grits ] ]",						"\t\t\t         ifFalse: [ ",						"\t\t\t\t         a car cdr = (#hash cons: (#browns cons: nil))",						"\t\t\t\t\t         ifTrue: [ #ketchup cons: a car ]",						"\t\t\t\t\t         ifFalse: [ #mustard cons: a car ] ] ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"self",						"\tassert: (aGoal solutions next: 1) readStream upToEnd",						"\tequals: { [ :a | ",						"\t\ta car isAtom",						"\t\t\tifTrue: [ ",						"\t\t\t\ta car = a cdr",						"\t\t\t\t\tifTrue: [ #hominy ]",						"\t\t\t\t\tifFalse: [ #grits ] ]",						"\t\t\tifFalse: [ ",						"\t\t\t\ta car cdr = (#hash cons: (#browns cons: nil))",						"\t\t\t\t\tifTrue: [ ",						"\t\t\t\t\t#ketchup cons:",						"\t\t\t\t\t\t(a car car cons: (#hash cons: (#browns cons: nil))) ]",						"\t\t\t\t\tifFalse: [ #mustard cons: a car ] ] ] unaryRBNode }"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 7925165,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_15_ancestorobackward" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_15_ancestorobackward",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :a :b :c | ",						"\t         theory ancestorº",						"\t\t         value: rewritten asRBNode",						"\t\t         value: ([ :z :x :v | ",						"\t\t\t          2 + z",						"\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t          x",						"\t\t\t\t\t\t          ifTrue: [ 3 ]",						"\t\t\t\t\t\t          ifFalse: [ 1 ] ]",						"\t\t\t\t          ifFalse: [ 3 - v ] ] ",						"\t\t\t\t          substituteVariablesUsingSequenceableCollection: { ",						"\t\t\t\t\t\t          a asRBNode.",						"\t\t\t\t\t\t          b asRBNode.",						"\t\t\t\t\t\t          c asRBNode }) ] asGoal ] asGoal.",						"",						"\tself",						"\t\tassert:",						"\t\t\t((aGoal solutions collect: [ :e | e formattedCode ]) next: 20)",						"\t\t\t\treadStream upToEnd",						"\t\tequals: #( '2 + •₀' '•₀",						"\tifTrue: [ 3 ]",						"\tifFalse: [ 1 ]' '3 - •₀' '2' '◊•₀' '◊•₀' '◊•₀' '◊•₀' '3' '1' '3' '◊•₀'",						"\t\t\t   '◊•₀' '◊•₀' '◊•₀' '◊•₀' '◊•₀' '◊•₀' '◊•₀' '◊•₀' ).",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: 20"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :a :b :c | ",						"         theory ancestorº",						"\t         value: rewritten asRBNode",						"\t         value: ([ :z :x :v | ",						"\t\t          2 + z",						"\t\t\t          ifTrue: [ ",						"\t\t\t\t          x",						"\t\t\t\t\t          ifTrue: [ 3 ]",						"\t\t\t\t\t          ifFalse: [ 1 ] ]",						"\t\t\t          ifFalse: [ 3 - v ] ] ",						"\t\t\t          substituteVariablesUsingSequenceableCollection: { ",						"\t\t\t\t\t          a asRBNode.",						"\t\t\t\t\t          b asRBNode.",						"\t\t\t\t\t          c asRBNode }) ] asGoal ] asGoal.",						"",						"self",						"\tassert:",						"\t\t((aGoal solutions collect: [ :e | e formattedCode ]) next: 20)",						"\t\t\treadStream upToEnd",						"\tequals: #( '2 + •₀' '•₀",						"\tifTrue: [ 3 ]",						"\tifFalse: [ 1 ]' '3 - •₀' '2' '◊•₀' '◊•₀' '◊•₀' '◊•₀' '3' '1' '3' '◊•₀'",						"\t\t   '◊•₀' '◊•₀' '◊•₀' '◊•₀' '◊•₀' '◊•₀' '◊•₀' '◊•₀' ).",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: 20"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 7924780,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_07" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_07",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :c | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | o ]",						"\t\t\t\t         do: [ :o :r | theory ifSameº value: r value: o ] ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :c | ",						"\t\t\t         (3 cons: nil) isAtom",						"\t\t\t\t         ifTrue: [ a ]",						"\t\t\t\t         ifFalse: [ c ] ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := self expectedRBNode_chapter_02_frame_7.",						"\tself",						"\t\tassert: aGoal solutions readStream upToEnd equals: { node };",						"\t\tassert: node formattedCode equals: '•₀",						"\tifTrue: [ ",						"\t\t(3 cons: nil) isAtom",						"\t\t\tifTrue: [ •₁ ]",						"\t\t\tifFalse: [ •₂ ] ]",						"\tifFalse: [ ",						"\t\t(3 cons: nil) isAtom",						"\t\t\tifTrue: [ •₁ ]",						"\t\t\tifFalse: [ •₂ ] ]'.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :c | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | o ]",						"\t\t\t         do: [ :o :r | theory ifSameº value: r value: o ] ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :a :c | ",						"\t\t         (3 cons: nil) isAtom",						"\t\t\t         ifTrue: [ a ]",						"\t\t\t         ifFalse: [ c ] ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := self expectedRBNode_chapter_02_frame_7.",						"self",						"\tassert: aGoal solutions readStream upToEnd equals: { node };",						"\tassert: node formattedCode equals: '•₀",						"\tifTrue: [ ",						"\t\t(3 cons: nil) isAtom",						"\t\t\tifTrue: [ •₁ ]",						"\t\t\tifFalse: [ •₂ ] ]",						"\tifFalse: [ ",						"\t\t(3 cons: nil) isAtom",						"\t\t\tifTrue: [ •₁ ]",						"\t\t\tifFalse: [ •₂ ] ]'.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8187823,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_33" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_33",						"",						"\t| aGoal node |",						"\tself skip.",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         #gyre cons:",						"\t\t\t\t\t\t         ((#callooh cons: (#callay cons: nil)) isUffish",						"\t\t\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t\t\t          #gimble cons:",						"\t\t\t\t\t\t\t\t\t          ((#callooh cons: (#callay cons: nil)) isBrillig",						"\t\t\t\t\t\t\t\t\t\t           ifTrue: [ #borogove cons: (#outgrabe cons: nil) ]",						"\t\t\t\t\t\t\t\t\t\t           ifFalse: [ #bandersnatch cons: (#wabe cons: nil) ]) ]",						"\t\t\t\t\t\t\t          ifFalse: [ o cons: (#vorpal cons: nil) ]) ]",						"\t\t\t\t         premise: [ :o | #gyre cons: o ]",						"\t\t\t\t         do: theory jabberwockyº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ ",						"\t\t\t         #gyre cons:",						"\t\t\t\t         ((#callooh cons: (#callay cons: nil)) isUffish",						"\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t          #gimble cons:",						"\t\t\t\t\t\t\t          ((#callooh cons: (#callay cons: nil)) isBrillig",						"\t\t\t\t\t\t\t\t           ifTrue: [ #borogove cons: (#outgrabe cons: nil) ]",						"\t\t\t\t\t\t\t\t           ifFalse: [ #bandersnatch cons: (#wabe cons: nil) ]) ]",						"\t\t\t\t\t          ifFalse: [ ",						"\t\t\t\t\t\t          (#callooh cons: (#callay cons: nil)) frabjous cons:",						"\t\t\t\t\t\t\t          (#vorpal cons: nil) ]) ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := self expectedRBNode_chapter_02_frame_15.",						"",						"\tself",						"\t\tassert: (aGoal solutions next: 1) readStream upToEnd",						"\t\tequals: { node };",						"\t\tassert: node formattedCode equals: '(•₀ = true",						"\t ifTrue: [ true ]",						"\t ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₁ ]'"					],					"body" : [						"| aGoal node |",						"self skip.",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         #gyre cons:",						"\t\t\t\t\t         ((#callooh cons: (#callay cons: nil)) isUffish",						"\t\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t\t          #gimble cons:",						"\t\t\t\t\t\t\t\t          ((#callooh cons: (#callay cons: nil)) isBrillig",						"\t\t\t\t\t\t\t\t\t           ifTrue: [ #borogove cons: (#outgrabe cons: nil) ]",						"\t\t\t\t\t\t\t\t\t           ifFalse: [ #bandersnatch cons: (#wabe cons: nil) ]) ]",						"\t\t\t\t\t\t          ifFalse: [ o cons: (#vorpal cons: nil) ]) ]",						"\t\t\t         premise: [ :o | #gyre cons: o ]",						"\t\t\t         do: theory jabberwockyº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ ",						"\t\t         #gyre cons: ((#callooh cons: (#callay cons: nil)) isUffish",						"\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t          #gimble cons:",						"\t\t\t\t\t\t          ((#callooh cons: (#callay cons: nil)) isBrillig",						"\t\t\t\t\t\t\t           ifTrue: [ #borogove cons: (#outgrabe cons: nil) ]",						"\t\t\t\t\t\t\t           ifFalse: [ #bandersnatch cons: (#wabe cons: nil) ]) ]",						"\t\t\t\t          ifFalse: [ ",						"\t\t\t\t\t          (#callooh cons: (#callay cons: nil)) frabjous cons:",						"\t\t\t\t\t\t          (#vorpal cons: nil) ]) ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := self expectedRBNode_chapter_02_frame_15.",						"",						"self",						"\tassert: (aGoal solutions next: 1) readStream upToEnd",						"\tequals: { node };",						"\tassert: node formattedCode equals: '(•₀ = true",						"\t ifTrue: [ true ]",						"\t ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₁ ]'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8188135,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_15" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_15",						"",						"\t| aGoal node |",						"\tself skip.",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b :c | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         (a = true",						"\t\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t\t          o",						"\t\t\t\t\t\t\t\t          ifTrue: [ a ]",						"\t\t\t\t\t\t\t\t          ifFalse: [ b ] ]",						"\t\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t\t         do: theory equalSameº.",						"",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         (a = true",						"\t\t\t\t\t\t          ifTrue: [ o ]",						"\t\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t\t         do: theory ifTrueº.",						"",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         (a = true",						"\t\t\t\t\t\t          ifTrue: [ o ]",						"\t\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t\t         premise: [ :o | ",						"\t\t\t\t\t         o",						"\t\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t\t         do: theory equalIfº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: (Dictionary new",						"\t\t\t\t          at: #a put: a asRBNode;",						"\t\t\t\t          at: #b put: b asRBNode;",						"\t\t\t\t          at: #c put: c asRBNode;",						"\t\t\t\t          yourself) ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :b :c | ",						"\t\t\t         (a = true",						"\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t          nil = nil",						"\t\t\t\t\t\t          ifTrue: [ a ]",						"\t\t\t\t\t\t          ifFalse: [ b ] ]",						"\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t         ifFalse: [ c ] ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := self expectedRBNode_chapter_02_frame_15.",						"",						"\tself",						"\t\tassert: (aGoal solutions next: 1) readStream upToEnd",						"\t\tequals: { node };",						"\t\tassert: node formattedCode equals: '(•₀ = true",						"\t ifTrue: [ true ]",						"\t ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₁ ]'.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: 1"					],					"body" : [						"| aGoal node |",						"self skip.",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b :c | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         (a = true",						"\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t          o",						"\t\t\t\t\t\t\t          ifTrue: [ a ]",						"\t\t\t\t\t\t\t          ifFalse: [ b ] ]",						"\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t         do: theory equalSameº.",						"",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         (a = true",						"\t\t\t\t\t          ifTrue: [ o ]",						"\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t         do: theory ifTrueº.",						"",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         (a = true",						"\t\t\t\t\t          ifTrue: [ o ]",						"\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t         premise: [ :o | ",						"\t\t\t\t         o",						"\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t         do: theory equalIfº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: (Dictionary new",						"\t\t\t          at: #a put: a asRBNode;",						"\t\t\t          at: #b put: b asRBNode;",						"\t\t\t          at: #c put: c asRBNode;",						"\t\t\t          yourself) ] ]",						"\t         asGoalWithUnaryASTof: [ :a :b :c | ",						"\t\t         (a = true",						"\t\t\t          ifTrue: [ ",						"\t\t\t\t          nil = nil",						"\t\t\t\t\t          ifTrue: [ a ]",						"\t\t\t\t\t          ifFalse: [ b ] ]",						"\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t         ifTrue: [ c ]",						"\t\t\t         ifFalse: [ c ] ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := self expectedRBNode_chapter_02_frame_15.",						"",						"self",						"\tassert: (aGoal solutions next: 1) readStream upToEnd",						"\tequals: { node };",						"\tassert: node formattedCode equals: '(•₀ = true",						"\t ifTrue: [ true ]",						"\t ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₁ ]'.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: 1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8188552,					"argumentNames" : [ ]				}			}		}	}}