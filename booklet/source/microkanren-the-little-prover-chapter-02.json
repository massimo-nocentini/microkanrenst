{	"classes" : {		"TheLittleProverTest" : {			"hash" : 2836736,			"definition" : "GoalAbstractTest subclass: #TheLittleProverTest\r\tinstanceVariableNames: 'theory'\r\tclassVariableNames: ''\r\tpackage: 'MicroKanren-Tests'",			"comment" : [				"A RBProgramNodeIdentityVisitorTest is a test class for testing the behavior of RBProgramNodeIdentityVisitor"			],			"category" : "MicroKanren-Tests"		}	},	"messages" : {		"test_chapter_02_EvenOlderGames_frame_15" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_15",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :b :c | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         (a = true",						"\t\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t\t          o",						"\t\t\t\t\t\t\t\t          ifTrue: [ a ]",						"\t\t\t\t\t\t\t\t          ifFalse: [ b ] ]",						"\t\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t\t         do: theory equalSameº.",						"",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         (a = true",						"\t\t\t\t\t\t          ifTrue: [ o ]",						"\t\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t\t         do: theory ifTrueº.",						"",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | ",						"\t\t\t\t\t         (a = true",						"\t\t\t\t\t\t          ifTrue: [ o ]",						"\t\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t\t         premise: [ :o | ",						"\t\t\t\t\t         o",						"\t\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t\t         do: theory equalIfº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: (Dictionary new",						"\t\t\t\t          at: #a put: a asRBNode;",						"\t\t\t\t          at: #b put: b asRBNode;",						"\t\t\t\t          at: #c put: c asRBNode;",						"\t\t\t\t          yourself) ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :b :c | ",						"\t\t\t         (a = true",						"\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t          nil = nil",						"\t\t\t\t\t\t          ifTrue: [ a ]",						"\t\t\t\t\t\t          ifFalse: [ b ] ]",						"\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t         ifFalse: [ c ] ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := self expectedRBNode_chapter_02_frame_15.",						"",						"\tself",						"\t\tassert: (aGoal solutions next: 1) asArray equals: { node };",						"\t\tassert: node formattedCode equals: '(•₀ = true",						"\t ifTrue: [ true ]",						"\t ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₁ ]'"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :b :c | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         (a = true",						"\t\t\t\t\t          ifTrue: [ ",						"\t\t\t\t\t\t          o",						"\t\t\t\t\t\t\t          ifTrue: [ a ]",						"\t\t\t\t\t\t\t          ifFalse: [ b ] ]",						"\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t         do: theory equalSameº.",						"",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         (a = true",						"\t\t\t\t\t          ifTrue: [ o ]",						"\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t         do: theory ifTrueº.",						"",						"\t\t         prover",						"\t\t\t         focus: [ :o | ",						"\t\t\t\t         (a = true",						"\t\t\t\t\t          ifTrue: [ o ]",						"\t\t\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t         premise: [ :o | ",						"\t\t\t\t         o",						"\t\t\t\t\t         ifTrue: [ c ]",						"\t\t\t\t\t         ifFalse: [ c ] ]",						"\t\t\t         do: theory equalIfº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: (Dictionary new",						"\t\t\t          at: #a put: a asRBNode;",						"\t\t\t          at: #b put: b asRBNode;",						"\t\t\t          at: #c put: c asRBNode;",						"\t\t\t          yourself) ] ]",						"\t         asGoalWithUnaryASTof: [ :a :b :c | ",						"\t\t         (a = true",						"\t\t\t          ifTrue: [ ",						"\t\t\t\t          nil = nil",						"\t\t\t\t\t          ifTrue: [ a ]",						"\t\t\t\t\t          ifFalse: [ b ] ]",						"\t\t\t          ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\t\t\t         ifTrue: [ c ]",						"\t\t\t         ifFalse: [ c ] ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := self expectedRBNode_chapter_02_frame_15.",						"",						"self",						"\tassert: (aGoal solutions next: 1) asArray equals: { node };",						"\tassert: node formattedCode equals: '(•₀ = true",						"\t ifTrue: [ true ]",						"\t ifFalse: [ #or = (#black cons: (#coffee cons: nil)) ])",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₁ ]'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157832,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_15_parento" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_15_parento",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         theory parentº",						"\t\t         value: false asLiteralRBNode",						"\t\t         value: rewritten asRBNode ] asGoal.",						"",						"\tself",						"\t\tassert: (aGoal solutions collect: [ :e | e formattedCode ]) asArray",						"\t\tequals: #( 'false = •₀' '[ false ]' 'false' 'false",						"\tifTrue: [ •₀ ]",						"\tifFalse: [ •₁ ]' 'false + •₀' '•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ false ]' '•₀ = false' '•₀",						"\tifTrue: [ false ]",						"\tifFalse: [ •₁ ]' 'false - •₀' '•₀ + false' 'false cons: •₀'",						"\t\t\t   '•₀ - false' '•₀ cons: false' ).",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         theory parentº",						"\t         value: false asLiteralRBNode",						"\t         value: rewritten asRBNode ] asGoal.",						"",						"self",						"\tassert: (aGoal solutions collect: [ :e | e formattedCode ]) asArray",						"\tequals: #( 'false = •₀' '[ false ]' 'false' 'false",						"\tifTrue: [ •₀ ]",						"\tifFalse: [ •₁ ]' 'false + •₀' '•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ false ]' '•₀ = false' '•₀",						"\tifTrue: [ false ]",						"\tifFalse: [ •₁ ]' 'false - •₀' '•₀ + false' 'false cons: •₀'",						"\t\t   '•₀ - false' '•₀ cons: false' ).",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894717,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_15_ancestoro" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_15_ancestoro",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         theory ancestorº",						"\t\t         value: false asLiteralRBNode",						"\t\t         value: rewritten asRBNode ] asGoal.",						"",						"\tself",						"\t\tassert:",						"\t\t((aGoal solutions collect: [ :e | e formattedCode ]) next: 25)",						"\t\t\tasArray",						"\t\tequals:",						"\t\t\t#( 'false = •₀' 'false = •₀ = •₁' '[ false ]' '[ false = •₀ ]'",						"\t\t\t   'false' 'false = •₀ = •₁ = •₂' 'false",						"\tifTrue: [ •₀ ]",						"\tifFalse: [ •₁ ]' 'false = •₀' 'false + •₀' '[ false = •₀ = •₁ ]'",						"\t\t\t   '•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ false ]' '[ false ] = •₀' '•₀ = false' 'false = •₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ ]' '•₀",						"\tifTrue: [ false ]",						"\tifFalse: [ •₁ ]' 'false = •₀ = •₁' 'false - •₀' '[ [ false ] ]'",						"\t\t\t   '•₀ + false' '[ false = •₀ ] = •₁' 'false cons: •₀'",						"\t\t\t   'false = •₀ + •₁' '•₀ - false' 'false = •₀ = •₁",						"\tifTrue: [ •₂ ]",						"\tifFalse: [ •₃ ]' '[ false ]' ).",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: 25"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         theory ancestorº",						"\t         value: false asLiteralRBNode",						"\t         value: rewritten asRBNode ] asGoal.",						"",						"self",						"\tassert:",						"\t((aGoal solutions collect: [ :e | e formattedCode ]) next: 25)",						"\t\tasArray",						"\tequals:",						"\t\t#( 'false = •₀' 'false = •₀ = •₁' '[ false ]' '[ false = •₀ ]'",						"\t\t   'false' 'false = •₀ = •₁ = •₂' 'false",						"\tifTrue: [ •₀ ]",						"\tifFalse: [ •₁ ]' 'false = •₀' 'false + •₀' '[ false = •₀ = •₁ ]'",						"\t\t   '•₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ false ]' '[ false ] = •₀' '•₀ = false' 'false = •₀",						"\tifTrue: [ •₁ ]",						"\tifFalse: [ •₂ ]' '•₀",						"\tifTrue: [ false ]",						"\tifFalse: [ •₁ ]' 'false = •₀ = •₁' 'false - •₀' '[ [ false ] ]'",						"\t\t   '•₀ + false' '[ false = •₀ ] = •₁' 'false cons: •₀'",						"\t\t   'false = •₀ + •₁' '•₀ - false' 'false = •₀ = •₁",						"\tifTrue: [ •₂ ]",						"\tifFalse: [ •₃ ]' '[ false ]' ).",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: 25"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894927,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_07" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_07",						"",						"\t| aGoal node |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :c | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t\t         prover",						"\t\t\t\t         focus: [ :o | o ]",						"\t\t\t\t         do: [ :o :r | theory ifSameº value: r value: o ] ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :c | ",						"\t\t\t         (3 cons: nil) isAtom",						"\t\t\t\t         ifTrue: [ a ]",						"\t\t\t\t         ifFalse: [ c ] ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tnode := self expectedRBNode_chapter_02_frame_7.",						"\tself",						"\t\tassert: aGoal solutions asArray equals: { node };",						"\t\tassert: node formattedCode equals: '•₀",						"\tifTrue: [ ",						"\t\t(3 cons: nil) isAtom",						"\t\t\tifTrue: [ •₁ ]",						"\t\t\tifFalse: [ •₂ ] ]",						"\tifFalse: [ ",						"\t\t(3 cons: nil) isAtom",						"\t\t\tifTrue: [ •₁ ]",						"\t\t\tifFalse: [ •₂ ] ]'.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal node |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :c | ",						"         ast",						"\t         acl: [ :prover | ",						"\t\t         prover",						"\t\t\t         focus: [ :o | o ]",						"\t\t\t         do: [ :o :r | theory ifSameº value: r value: o ] ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :a :c | ",						"\t\t         (3 cons: nil) isAtom",						"\t\t\t         ifTrue: [ a ]",						"\t\t\t         ifFalse: [ c ] ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"node := self expectedRBNode_chapter_02_frame_7.",						"self",						"\tassert: aGoal solutions asArray equals: { node };",						"\tassert: node formattedCode equals: '•₀",						"\tifTrue: [ ",						"\t\t(3 cons: nil) isAtom",						"\t\t\tifTrue: [ •₁ ]",						"\t\t\tifFalse: [ •₂ ] ]",						"\tifFalse: [ ",						"\t\t(3 cons: nil) isAtom",						"\t\t\tifTrue: [ •₁ ]",						"\t\t\tifFalse: [ •₂ ] ]'.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4157970,					"argumentNames" : [ ]				}			}		},		"test_chapter_02_EvenOlderGames_frame_05" : {			"senders" : [				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc"			],			"implementors" : {				"TheLittleProverTest" : {					"sourceCode" : [						"test_chapter_02_EvenOlderGames_frame_05",						"",						"\t| aGoal |",						"\taGoal := [ :rewritten | ",						"\t         [ :ast | ",						"\t         [ :a :c | ",						"\t         ast",						"\t\t         acl: [ :prover | ",						"\t\t         prover focus: [ :o | o ] do: theory ifSameº ]",						"\t\t         then: [ :asts | ",						"\t\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t\t         contextVariables: Dictionary empty ] ]",						"\t\t         asGoalWithUnaryASTof: [ :a :c | ",						"\t\t\t         a",						"\t\t\t\t         ifTrue: [ 3 ]",						"\t\t\t\t         ifFalse: [ c ] ]",						"\t\t         contextVariables: Dictionary empty ] asGoal.",						"",						"\tself assert: aGoal solutions asArray equals: { 3 asLiteralRBNode }.",						"",						"\t^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"body" : [						"| aGoal |",						"aGoal := [ :rewritten | ",						"         [ :ast | ",						"         [ :a :c | ",						"         ast",						"\t         acl: [ :prover | ",						"\t         prover focus: [ :o | o ] do: theory ifSameº ]",						"\t         then: [ :asts | ",						"\t         theory unifyº value: asts last value: rewritten asRBNode ]",						"\t         contextVariables: Dictionary empty ] ]",						"\t         asGoalWithUnaryASTof: [ :a :c | ",						"\t\t         a",						"\t\t\t         ifTrue: [ 3 ]",						"\t\t\t         ifFalse: [ c ] ]",						"\t         contextVariables: Dictionary empty ] asGoal.",						"",						"self assert: aGoal solutions asArray equals: { 3 asLiteralRBNode }.",						"",						"^ self exportComputationTreeOfGoal: aGoal limitedTo: -1"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3894785,					"argumentNames" : [ ]				}			}		}	}}